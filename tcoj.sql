/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50714
Source Host           : localhost:3306
Source Database       : tcoj

Target Server Type    : MYSQL
Target Server Version : 50714
File Encoding         : 65001

Date: 2017-04-27 16:10:52
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for black_user
-- ----------------------------
DROP TABLE IF EXISTS `black_user`;
CREATE TABLE `black_user` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `ip` varchar(30) CHARACTER SET utf8 NOT NULL,
  `status` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of black_user
-- ----------------------------

-- ----------------------------
-- Table structure for contest_list
-- ----------------------------
DROP TABLE IF EXISTS `contest_list`;
CREATE TABLE `contest_list` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(100) CHARACTER SET utf8 NOT NULL,
  `start_time` int(11) NOT NULL,
  `end_time` int(11) NOT NULL,
  `type` varchar(100) CHARACTER SET utf8 NOT NULL,
  `status` varchar(100) CHARACTER SET utf8 NOT NULL,
  `anthor` varchar(100) CHARACTER SET utf8 NOT NULL,
  `password` varchar(30) CHARACTER SET utf8 DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of contest_list
-- ----------------------------

-- ----------------------------
-- Table structure for contest_problem
-- ----------------------------
DROP TABLE IF EXISTS `contest_problem`;
CREATE TABLE `contest_problem` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `contest_list_id` int(5) NOT NULL,
  `title` text NOT NULL,
  `time_limit` int(7) NOT NULL DEFAULT '1000',
  `memory_limit` int(7) NOT NULL DEFAULT '32768',
  `submissions` int(7) NOT NULL DEFAULT '0',
  `accepted` int(7) NOT NULL DEFAULT '0',
  `description` text NOT NULL,
  `input` text NOT NULL,
  `output` text NOT NULL,
  `sample_input` text NOT NULL,
  `sample_output` text NOT NULL,
  `author` text NOT NULL,
  `source` text NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '1',
  `contest_problem_id` int(5) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of contest_problem
-- ----------------------------

-- ----------------------------
-- Table structure for contest_user_problem
-- ----------------------------
DROP TABLE IF EXISTS `contest_user_problem`;
CREATE TABLE `contest_user_problem` (
  `id` int(6) unsigned NOT NULL AUTO_INCREMENT,
  `contest_user_id` int(6) NOT NULL,
  `contest_list_id` int(11) NOT NULL,
  `contest_problem_id` int(6) NOT NULL,
  `submit_time` int(11) NOT NULL,
  `judge_status` int(1) NOT NULL,
  `exe_time` varchar(6) NOT NULL DEFAULT '0',
  `exe_memory` varchar(6) NOT NULL,
  `code_len` int(6) NOT NULL,
  `language` varchar(30) NOT NULL,
  `nickname` varchar(30) NOT NULL,
  `filepath` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of contest_user_problem
-- ----------------------------

-- ----------------------------
-- Table structure for judge_detail
-- ----------------------------
DROP TABLE IF EXISTS `judge_detail`;
CREATE TABLE `judge_detail` (
  `id` int(9) unsigned NOT NULL AUTO_INCREMENT,
  `user_problem_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  `judge_status` int(11) NOT NULL DEFAULT '8',
  `exe_time` int(11) NOT NULL DEFAULT '0',
  `exe_memory` int(11) NOT NULL DEFAULT '0',
  `score` int(11) NOT NULL DEFAULT '0',
  `input_file_path` varchar(255) NOT NULL,
  `output_file_path` varchar(255) NOT NULL,
  `group_score` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of judge_detail
-- ----------------------------

-- ----------------------------
-- Table structure for label_info
-- ----------------------------
DROP TABLE IF EXISTS `label_info`;
CREATE TABLE `label_info` (
  `id` int(8) unsigned NOT NULL AUTO_INCREMENT,
  `label_name` text NOT NULL,
  `status` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of label_info
-- ----------------------------
INSERT INTO `label_info` VALUES ('1', '基础练习第一期', '0');
INSERT INTO `label_info` VALUES ('2', '基础练习第二期', '0');
INSERT INTO `label_info` VALUES ('3', '数学', '0');
INSERT INTO `label_info` VALUES ('4', '数组', '0');
INSERT INTO `label_info` VALUES ('5', '贪心', '0');
INSERT INTO `label_info` VALUES ('6', 'noip', '0');
INSERT INTO `label_info` VALUES ('7', '枚举', '0');
INSERT INTO `label_info` VALUES ('8', '基础练习第三期', '0');
INSERT INTO `label_info` VALUES ('9', '递归', '0');
INSERT INTO `label_info` VALUES ('10', '二分', '0');
INSERT INTO `label_info` VALUES ('11', '递推', '0');
INSERT INTO `label_info` VALUES ('12', '二进制', '0');
INSERT INTO `label_info` VALUES ('13', '高精度', '0');
INSERT INTO `label_info` VALUES ('14', '排序', '0');
INSERT INTO `label_info` VALUES ('15', '初等数论', '0');
INSERT INTO `label_info` VALUES ('16', '深度优先搜索算法', '0');
INSERT INTO `label_info` VALUES ('17', '字符串', '0');
INSERT INTO `label_info` VALUES ('18', '动态规划', '0');
INSERT INTO `label_info` VALUES ('19', '优先队列', '0');
INSERT INTO `label_info` VALUES ('20', '模拟', '0');

-- ----------------------------
-- Table structure for level
-- ----------------------------
DROP TABLE IF EXISTS `level`;
CREATE TABLE `level` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `content` text NOT NULL,
  `entrance_title` varchar(255) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of level
-- ----------------------------
INSERT INTO `level` VALUES ('1', '新手村', '任何一个伟大的目标，都有一个微不足道的开始。', '青铜入口', '0');
INSERT INTO `level` VALUES ('2', '普及练习场', '普及组选手可冲刺训练，提高组选手亦可在此巩固基础。', '白银入口', '0');
INSERT INTO `level` VALUES ('3', '提高历练地', '已经去除了普及组难度的，请组织放心。成长大牛之必写题！！！', '黄金入口', '0');
INSERT INTO `level` VALUES ('4', '省选斗兽场', '（试炼场建造中。。）', '钻石入口', '0');
INSERT INTO `level` VALUES ('5', 'NOI神殿', '（试炼场建造中。。）', '王者入口', '0');

-- ----------------------------
-- Table structure for level_msg
-- ----------------------------
DROP TABLE IF EXISTS `level_msg`;
CREATE TABLE `level_msg` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `level_id` int(11) NOT NULL DEFAULT '1',
  `level_title` varchar(255) NOT NULL,
  `level_abstract` text NOT NULL,
  `pass_number` int(11) NOT NULL DEFAULT '0',
  `level_name` varchar(255) NOT NULL,
  `problem_number` int(11) NOT NULL DEFAULT '0',
  `status` int(11) NOT NULL DEFAULT '0',
  `pre_level_id` int(11) NOT NULL DEFAULT '0',
  `least_pass_number` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of level_msg
-- ----------------------------

-- ----------------------------
-- Table structure for login_msg
-- ----------------------------
DROP TABLE IF EXISTS `login_msg`;
CREATE TABLE `login_msg` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `ip` varchar(30) NOT NULL,
  `login_time` int(12) NOT NULL,
  `status` varchar(100) NOT NULL,
  `area` varchar(100) DEFAULT NULL,
  `username` varchar(40) NOT NULL,
  `password` varchar(40) NOT NULL,
  `user_id` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of login_msg
-- ----------------------------

-- ----------------------------
-- Table structure for problem
-- ----------------------------
DROP TABLE IF EXISTS `problem`;
CREATE TABLE `problem` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `time_limit` int(7) NOT NULL DEFAULT '1000',
  `memory_limit` int(7) NOT NULL DEFAULT '32768',
  `submissions` int(7) NOT NULL DEFAULT '0',
  `accepted` int(7) NOT NULL DEFAULT '0',
  `description` text NOT NULL,
  `input` text NOT NULL,
  `output` text NOT NULL,
  `sample_input` text NOT NULL,
  `sample_output` text NOT NULL,
  `author` text NOT NULL,
  `source` text NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '1',
  `output_limit` int(9) DEFAULT '0',
  `case_number` int(11) NOT NULL DEFAULT '10',
  `difficulty` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20205 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of problem
-- ----------------------------
INSERT INTO `problem` VALUES ('10001', 'a+b', '0', '32768', '0', '0', '计算两个整数a与b的值.', '两个整数a, b(-1e9&lt;=a, b&lt;=1e9).\\n\\n', 'a+b的值.', '1 1', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10002', 'a+b(2)', '1000', '32768', '0', '0', '计算两个double类型数的和。', '一行内两个double类型的数a, b(-1e9&lt;=a, b&lt;=1e9)。', 'a+b的值，保留两位小数.', '5.5 4.5', '10.00', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10003', 'a+b+c', '1000', '32768', '0', '0', '计算三个整数a, b, c的和.', 'a, b, c(-1e9&lt;=a, b, c&lt;=1e9).', 'a+b+c的值.', '1 2 3', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10004', 'a+b和c(2)', '1000', '32768', '0', '0', '给定三个整数a, b, c，判断a+b&gt;c是否成立.', '三个整数a, b, c(-2^63&lt;=a, b, c&lt;2^63).', '如果a+b&gt;c, 输出Yes, 否则输出No.', '2 3 4', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10005', 'k的倍数', '1000', '32768', '0', '0', '给定两个数n和k, 统计[1, n]范围内k的倍数的个数.', '两个整数n, k(1&lt;=n, k&lt;=1e9).', '[1,n]内k的倍数的个数.', '4 2', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10006', 'k的倍数(2)', '1000', '32768', '0', '0', '给定两个正整数n和k, 计算n最少增加多少后能被k整除.', '两个正整数n, k(1&lt;=n, k&lt;=1e9).', '一个整数, 即答案', '3 2', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10007', 'k的倍数(3)', '1000', '32768', '0', '0', '统计区间[l, r]之间的数中有多少个是k的倍数.', '三个整数l, r, k(1&lt;=l&lt;=r&lt;=1e9, 1&lt;=k&lt;=1e9).', '一个整数, 即答案.', '1 10 5', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10008', '格式化时间', '1000', '32768', '0', '0', '将日期和时间按照指定格式转化', '一个以&quot;年/月/日, 时:分:秒&quot;格式表示时间的字符串. 日期的范围为1900/1/1到2200/12/31, 时间范围为0:00:00到23:59:59.', '将该时间转化格式为&quot;月 日, 年  时:分:秒 PM/AM&quot;. 格式要求如下:\r\n1. 月的输出格式为英文中相应月份的缩写. (英文中12个月对应的缩写分别是Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec). \r\n2. 年和时之间应间隔两个空格, 其余需要间隔的位置只输出一个空格. \r\n3. 分和秒必须输出两位数字, 例如一时五分七秒应输出1:05:07, 其余情况不要添加前导0. \r\n4. 需要将24小时制转化为12小时制, 0点到11点为上午AM, 12点到23点为下午PM. (注意: 0点应写作12点, 如0:00:00应转化为12:00:00 AM).', '2016/1/1, 12:30:00', 'Jan 1, 2016  12:30:00 PM', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10009', '星期几(2)', '1000', '32768', '0', '0', '已知今天是星期几, 求n天后是星期几.', '一行内两个整数, 第一个整数k(0&lt;=k&lt;=6), 表示现在是星期几, 其中0表示星期日. 第二个整数n.(0&lt;=n&lt;=1e9), 表示过了多少天.', '输出n天后是星期几. 用英文单词表示, 星期日到星期六的英文单词分别是Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday.', '4 4', 'Monday', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10010', '星期几(3)', '1000', '32768', '0', '0', '小明每周一到周五坐公交车去学校. 小明乘坐的公交车很特殊, 票价每天都不一样, 从周一到周五的票价从1块到5块递增. 小明每天需要来回乘坐, 因此每天花费为两倍票价. 周末不用上学.已知今天是星期几, 请计算n天内(包括今天在内)需要花费的车费是多少.', '两个整数. k(0&lt;=k&lt;=6)表示现在星期几, 星期天用0表示. n(0&lt;=n&lt;=1e9)表示天数.', '输出一共用的车费.', '1 1', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10011', '算数表达式', '1000', '32768', '0', '0', '计算简单的算数表达式.', '一行字符串, 表示一个表达式, 按照&quot;a op b&quot;的格式. 其中a, b是整数(-1e9&lt;=a, b&lt;=1e9). op是运算符, op可能是&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;之一. 题目保证除数不是0.', '表达式的运算结果.', '10 + 2', '12', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10012', '2, 3, 5的倍数', '1000', '32768', '0', '0', '统计[1,n]区间内不能被2, 3和5整除的数的个数.', '一个整数n(1&lt;=n&lt;=1e9).', '一个整数, 即答案.', '20', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10013', '1, 10, 100...', '1000', '32768', '0', '0', '将1, 10, 100, 1000...组成序列1101001000..., 判断这个序列的第n位是0还是1.', '一个整数n(1&lt;=n&lt;=1e9).', '输出序列的第n位.', '2', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10014', '字符类型', '1000', '32768', '0', '0', '判断一个字符是哪种类型.', '输入一个ASCII字符.', '1. 如果字符是大写字母, 元音输出&quot;Upper Vowel&quot;, 其他情况输出&quot;Upper Letter&quot;. (字母中, \'a\', \'e\', \'i\', \'o\', \'u\'是元音字母(不区分大小写))\r\n2. 如果字符是小写字母, 元音输出&quot;Lower Vowel&quot;, 其他情况输出&quot;Lower Letter&quot;.\r\n3. 如果字符是数字, 输出&quot;Digit&quot;.\r\n4. 字符是其他类型, 输出&quot;Other&quot;.', 'B', 'Upper Letter', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10015', '读数字', '1000', '32768', '0', '0', '用拼音读一个两位数. (一到十的拼音分别是&quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;, &quot;shi&quot;).', '一个整数n(10&lt;=n&lt;=99).', '把数按照数学中数的读法读出来, 输出到一行.', '23', 'er shi san', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10016', '反转数字(2)', '1000', '32768', '0', '0', '反转一个数字.', '一个整数n(-1e9&lt;=n&lt;=1e9).', '将n反转后的数, 除了0以外不要保留前导0.', '123', '321', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10017', 'a+b和c', '1000', '32768', '0', '0', '给定三个整数a, b, c，判断a+b&gt;c是否成立.', '三个整数a, b, c(-2^31&lt;=a, b, c&lt;2^31).', '如果a+b&gt;c, 输出Yes, 否则输出No.', '1 2 3', 'No', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10018', 'n个数之和(2)', '1000', '32768', '0', '0', '计算n个数的和.', '第一行, 一个整数n(0&lt;=n&lt;=10000).\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '输出n个数的和.', '3\r\n1 2 3', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10019', 'n个数之和', '1000', '32768', '0', '0', '计算n个数的和.', '第一行, 一个整数n(0&lt;=n&lt;=10000).\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '输出n个数的和.', '3\r\n1 2 3', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10020', '反转数组', '1000', '32768', '0', '0', '将数组中的元素逆序输出.', '第一行, 一个整数n(0&lt;=n&lt;=100).\r\n第二行, 一个数组a, 包含n个整数(-1e9&lt;=a[I]&lt;=1e9).', '在一行内反向输出数组的元素.', '3\r\n1 2 3', '3 2 1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10021', '交换数组相邻元素', '1000', '32768', '0', '0', '对一个数组a, 两个元素一组交换a中相邻的元素, 即第1个元素和第2个元素交换, 第3个元素和第4个元素交换...如果剩余不足两个元素则不交换.', '第一行, 一个整数n(0&lt;=n&lt;=100).\r\n第二行, 一个数组a, 包含n个整数(-1e9&lt;=a[i]&lt;1e9).', '按照规则交换后, 将数组元素输出到一行.', '3\r\n1 2 3', '2 1 3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10022', '数组中最大的值', '1000', '32768', '0', '0', '找出数组中出现的最大的值.', '第一行, 一个整数n(1&lt;=n&lt;=10000).\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '输出数组中最大的值.', '3\r\n1 2 2', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10023', '数组中第二大的值', '1000', '32768', '0', '0', '找出数组中出现的第二大的值.', '第一行, 一个整数n(1&lt;=n&lt;=10000).\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '输出数组中第二大的值, 如果数组中所有元素都相等, 则输出最大的值.', '3\r\n1 2 2', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10024', '数组重复元素', '1000', '32768', '0', '0', '给一个数组, 判断数组中是否存在重复元素, 即存在a[i]=a[j], 并且i和j不相等.', '第一行, 一个整数n(1&lt;=n&lt;=100).\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '如果存在则输出Yes, 否则输出No.', '4\r\n1 2 3 1', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10025', '打印沙漏', '1000', '32768', '0', '0', '把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印\r\n*****\r\n ***\r\n  *\r\n ***\r\n*****\r\n所谓&quot;沙漏形状&quot;, 是指每行输出奇数个符号; 各行符号中心对齐; 相邻两行符号数差2; 符号数先从大到小顺序递减到1, 再从小到大顺序递增; 首尾符号数相等.\r\n给定任意N个符号, 不一定能正好组成一个沙漏. 要求打印出的沙漏能用掉尽可能多的符号.', '输入在一行给出1个正整数n(1&lt;=n&lt;=1000)和一个符号, 中间以空格分隔.', '首先打印由给定符号组成的最大沙漏, 然后打印剩余的字符数. 注意在每行的末尾不要打印多余的空格!', '19 *', '*****\r\n ***\r\n  *\r\n ***\r\n*****\r\n2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10026', '数组重复元素(2)', '1000', '32768', '0', '0', '给一个数组, 判断数组中是否存在重复元素, 即存在a[i]=a[j], 并且i不等于j. 同时要求i和j的距离不大于k(i和j的距离 等于i, j中较大的数减去较小的数).', '第一行, 两个整数, n(1&lt;=n&lt;=100)表示数组的元素个数, k(0&lt;=k&lt;n)即题目中要求的最远距离.\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '如果存在满足条件的i和j, 输出Yes, 否则输出No.', '4 3\r\n1 2 3 1', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10027', '质数检测', '1000', '32768', '0', '0', '判断一个正整数是不是质数.', '一个整数n(1&lt;=n&lt;=1e6).', '如果是质数, 输出Yes, 否则输出No.', '2', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10028', '质数检测(2)', '1000', '32768', '0', '0', '判断一个正整数是不是质数.', '一个整数n(1&lt;=n&lt;=1e9).', '如果是质数, 输出Yes, 否则输出No.', '2', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10029', '被3整除', '1000', '32768', '0', '0', '给定两个整数a, b, 判断a+b能否被3整除.', '两个整数a, b(-2^63&lt;=a, b&lt;2^63).', '如果a+b能被3整除, 输出Yes, 否则输出No.', '10 2', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10030', '数出现的次数', '1000', '32768', '0', '0', '统计数组中一个整数k出现的次数.', '第一行, 两个整数n(1&lt;=n&lt;=10000)表示数组元素个数, k(-2^31&lt;=k&lt;2^31)表示要统计的整数.\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '输出数组a中k出现了多少次.', '5 4\r\n1 2 3 4 5', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10031', '打印三角形', '1000', '32768', '0', '0', '给定层数, 按下列格式打印三角形.\r\n  *\r\n ***\r\n*****\r\n每行输出奇数个符号; 各行符号中心对齐; 相邻两行符号数差2.', '一个整数n(1&lt;=n&lt;=100). 表示三角形的层数.', '按照格式打印三角形, 注意最后一行左边不能有空格, 每行的末尾不能由多余的空格.', '4', '   *\r\n  ***\r\n *****\r\n*******', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10032', '数数字', '1000', '32768', '0', '0', '把前n个整数顺次写在一起, 组成序列: 123456789101112...统计数字0-9各出现了多少次.', '一个整数n(1&lt;=n&lt;=10000).', '一行十个整数, 分别表示数字0-9出现的次数.', '10', '1 2 1 1 1 1 1 1 1 1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10033', '最近的两个数', '1000', '32768', '0', '0', '给定一个数组, 找出其中两个数, 使它们的距离最小. (两个数的距离是大数减去小数的差)', '第一行, 一个整数n(2&lt;=n&lt;=1000).\r\n第二行, 一个数组a, 包含n个整数(-2^31&lt;=a[i]&lt;2^31).', '两个数之间的最小距离.', '3\r\n1 2 1', '0', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10034', '最近的两个数(2)', '1000', '32768', '0', '0', '给定一个数组, 找出其中两个数, 使它们的距离最小. (两个数的距离是大数减去小数的差)', '第一行, 一个整数n(2&lt;=n&lt;=1000).\r\n第二行, 一个数组a, 包含n个整数(-1e9&lt;=a[i]&lt;1e9).', '输出距离最小的两个数的下标i和j(下标从1开始).\r\n如果存在多对满足条件的i, j, 尽量使i最小, 如果存在i相等的情况, 尽量使j最小.', '4\r\n2 3 4 5', '1 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10035', '平均数(2)', '1000', '32768', '0', '0', '计算数组元素的平均数.', '第一行, 一个整数n(1&lt;=n&lt;=1000).第二行, 一个数组a, 包含n个整数(-1e9&lt;=a[i]&lt;=1e9).', 'n个数的平均数, 保留两位小数.', '4\r\n1 2 3 4', '2.50', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10036', '众数', '1000', '32768', '0', '0', '找出数组元素的众数, 即出现次数最多的数.', '第一行, 一个整数n(1&lt;=n&lt;=10000).\r\n第二行, 一个数组a, 包含n个整数(1&lt;=a[i]&lt;=1000).', '输出众数, 如果众数不唯一, 则输出最小的.', '5\r\n1 1 2 2 3', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10037', '两个数的和', '1000', '32768', '0', '0', '给定一个数组a和一个整数k, 计算有多少种方法选择其中的两个数, 使它们的和刚好是k.', '第一行, 两个整数n(1&lt;=n&lt;=50000), k(1&lt;=k&lt;=10000). n表示数组元素个数, k表示需要找的两个数的和.\r\n第二行, 一个数组a, 包含n个整数(1&lt;=a[i]&lt;=5000).', '输出选择两个数, 和恰好等于k的情况数.', '5 6\r\n1 2 3 4 5', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10038', '质数有多少个', '1000', '32768', '0', '0', '给定范围[l, r], 找出范围内的质数有多少个.', '两个整数l, r(0&lt;=l, r&lt;=10000).', '[l,r]内质数的个数.', '2 7', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10039', '2的幂', '1000', '32768', '0', '0', '1, 2, 4, 8, 16...这些数都是2的幂, 只能被1或2或自身整除. 给定一个整数n, 找出不超过n的最大的2的幂.', '一个整数n(1&lt;=n&lt;2^31).', '输出不超过n的最大的2的幂.', '17', '16', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10040', '2的幂(2)', '1000', '32768', '0', '0', '1, 2, 4, 8, 16...这些数都是2的幂, 只能被1或2或自身整除. 给定一个整数n, 找出不超过n的最大的2的幂.', '一个整数n(1&lt;=n&lt;2^63).', '输出不超过n的最大的2的幂.', '17', '16', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10041', '打印日历', '1000', '32768', '0', '0', '给出一个月有多少天, 以及这个月的1号是星期几, 按照下列格式打印这个月的日历:\r\nSu      Mo      Tu      We      Th      Fr      Sa\r\n                1       2       3       4       5\r\n6       7       8       9       10      11      12\r\n13      14      15      16      17      18      19\r\n20      21      22      23      24      25      26\r\n27      28      29      30\r\n从Su到Sa代表星期日到星期六.', '两个整数, n(28&lt;=n&lt;=31)表示这个月的天数, k(0&lt;=k&lt;=6)表示这个月的1号是星期几, 其中k=0表示是星期日.', '第一行, 打印星期天到星期六的符号.\r\n第二行开始, 依次打印每一天的日期.\r\n打印时使用制表符\'\\t\'间隔(如果1号不是星期天, 那么需要在第二行前添加\'\\t\'缩进), 每一行最后不要打印多余的制表符. 注意最后一天之后也是直接换行, 不要打印多余的制表符.', '30 2', 'Su      Mo      Tu      We      Th      Fr      Sa\r\n                1       2       3       4       5\r\n6       7       8       9       10      11      12\r\n13      14      15      16      17      18      19\r\n20      21      22      23      24      25      26\r\n27      28      29      30', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10042', '数的位数', '1000', '32768', '0', '0', '给定一个数, 计算这个数由几个数字组成.', '一个整数n(-2^31&lt;=n&lt;2^31).', '输出n由几个数字组成.', '123', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10043', '数字根', '1000', '32768', '0', '0', '数字根是将一自然数的各个位数相加, 若加完后的值大于等于10的话, 则继续将各位数进行相加直到其值小于10为止, 最后得到的小于10的数字就是数字根.例如1234, 首先计算1+2+3+4=10, 然后再计算1+0=1, 所以1234的数字根是1. ', '一个整数n(0&lt;=n&lt;=1e9).', 'n的数字根.', '1234', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10044', '一年中的第几天', '1000', '32768', '0', '0', '给定年, 月, 日, 计算这一天是这一年中的第几天.', '三个整数, year(1000&lt;=year&lt;=5000)表示年, month(1&lt;=month&lt;=12)表示月, date(1&lt;=date&lt;=28)表示日.', '输出这一天是一年中的第几天.', '2016 1 1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10045', '下一个国庆节', '1000', '32768', '0', '0', '每年的10月1日是中国的国庆节. 给定今天的日期, 计算到下一个国庆节还有多久.', '三个整数, year(1000&lt;=year&lt;=5000)表示年, month(1&lt;=month&lt;=12)表示月, date(1&lt;=date&lt;=28)表示日.', '输出距离下一个国庆节还有多少天.', '2016 9 30', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10046', '回文数', '1000', '32768', '0', '0', '给定正整数n, 计算[1,n]范围内有多少个回文数.回文数是将数字反转后和原数相同的数, 如12321, 3443...', '一个整数n(1&lt;=n&lt;=10000).', '[1,n]范围内回文数的个数.', '100', '18', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10047', '杨辉三角', '1000', '32768', '0', '0', '给定层数n, 按照这样的格式打印杨辉三角的前n行:\r\n1\r\n1 1\r\n1 2 1\r\n1 3 3 1\r\n1 4 6 4 1\r\n杨辉三角的每一行满足这样的性质, 对于第i行的第j个元素:\r\n1. 如果j等于1或者i, 这个元素是1.\r\n2. 其他情况, 这个元素等于i-1行的第j个元素和第j-1个元素的和.', '一个正整数n(1&lt;=n&lt;=30), 表示需要打印多少行.', '按照上述格式打印杨辉三角的前n行, 注意每行的末尾不要打印多余的空格.', '5', '1\r\n1 1\r\n1 2 1\r\n1 3 3 1\r\n1 4 6 4 1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10048', '斐波那契数列', '1000', '32768', '0', '0', '斐波那契数列的定义如下:\r\nF(0) = 0\r\nF(1) = 1\r\nF(n) = F(n - 1) + F(n - 2) (n &gt;= 2)\r\n(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...)\r\n给定n, 求出F(n).', '一个整数n(0&lt;=n&lt;=30).', '题目中描述的F(n).', '0', '0', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10049', '部分回文数', '1000', '32768', '0', '0', '给定一个正整数, 计算有多少对位置对称的数字是相等的. (从左边数的第i位和从右边数的第i位是位置对称的).如数1423251, 第1位数字和最后1位数字都是1, 第3位数字和倒数第3位数字都是2, 所以有2对相等. 注意第4位数字和倒数第4位数字在同一个位置, 因此不算在内.', '一整正整数n(1&lt;=n&lt;2^31).', '输出有多少对位置对称的数字相等.', '1423251', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10050', '交换', '1000', '32768', '0', '0', '输入两个整数, 把他们交换后输出.', '两个整数a, b(-2^31&lt;=a, b&lt;2^31).', '交换后输出a, b.', '1 5', '5 1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10051', 'BMI指数', '1000', '32768', '0', '0', '小明对于自己日益增长的体重表示深感不安, 因此请你编写一个程序, 根据他的体重w和身高h计算出BMI指数 = w / (h * h),并根据BMI指数判断他的体重是否正常.', '两个实数w, h, 分别表示小明的体重(单位为kg)和身高(单位为m).', '1. 如果BMI指数&lt;18.5, 输出&quot;Thin.&quot;;\r\n2. 如果BMI指数&gt;23.9, 输出&quot;Fat.&quot;;\r\n3. 否则输出&quot;Normal.&quot;;\r\n(输出时去掉双引号)', '62.5 1.65', 'Normal.', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10052', '翻倍', '1000', '32768', '0', '0', '将一个整数翻倍后输出.', '一个整数x(-1e9&lt;=x&lt;=1e9).', 'x翻倍后的结果.', '5', '10', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10053', '星期几', '1000', '32768', '0', '0', '输入一个整数k,输出一个星期中的第k天是星期几. (一个星期的第一天是星期天.)', '一个整数k, 表示星期中的第几天.', '输出第k天是星期几. 用英文单词表示, 星期日到星期六的英文单词分别是Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday. 如果k不在[1,7]的范围内, 输出&quot;Invalid&quot;.', '3', 'Tuesday', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10054', '三角形', '1000', '32768', '0', '0', '小明现在手上有三根长度分别为x, y, z的木棍. 他想知道, 这三根木棍是否能组成一个三角形, 你能帮帮他么?', '三个整数x, y, z(1&lt;=x, y, z&lt;=1000)', '如果可以组成三角形, 输出Yes, 否则输出No.', '6 6 6', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10055', '这个月有几天', '1000', '32768', '0', '0', '输入一个整数n, 求解闰年中的第n个月有多少天.', '一个正整数n.', '输出一个整数, 代表闰年中的第n个月有多少天. 若n不合法，输出&quot;Invalid.&quot;(不包含双引号).', '2', '29', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10056', '反转数字', '1000', '32768', '0', '0', '输入一个五位数, 请将它颠倒顺序后输出.', '一个五位数n(10000&lt;=n&lt;=99999).', '反转后的n(不要保留前导0).', '99100', '199', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10057', '比大小', '1000', '32768', '0', '0', '找出两个整数中的最大数.', '两个整数a, b(-2^31&lt;=a, b&lt;2^31).', 'a, b中较大的数.', '29 20821', '20821', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10058', '区间', '1000', '32768', '0', '0', '判断一个数a是否在区间[x, y]内, 若是则输出&quot;yes&quot;,  否则输出&quot;no&quot;(不包含双引号).', '三个整数a, x, y.', '如果a在[x,y]内, 输出&quot;yes&quot;, 否则输出&quot;no&quot;.', '8 6 9', 'yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10059', '比大小(2)', '1000', '32768', '0', '0', '找出三个整数中的最大数', '一行三个整数.', '三个整数中最大的数.', '2 6 3', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10060', '矩形', '1000', '32768', '0', '0', '判断一个点(x, y)是否在左下角为(xmin, ymin), 右上角为(xmax, ymax)的矩形中.(在矩形的边上也算在矩形中)', '一行，包含六个整数x, y, xmin, ymin, xmax, ymax. 数据均在int范围内.', '若点在矩形中, 输出&quot;In.&quot;, 否则输出&quot;Out.&quot;(不包含引号).', '1 1 0 0 2 2', 'In.', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10061', '十六进制', '1000', '32768', '0', '0', '小明需要你制作一个程序, 帮他将一个小于16的十进制数转换为十六进制数. (十六进制中, 10到15分别用A, B, C, D, E, F)表示.', '一个小于16的正整数n(0&lt;=n&lt;16).', 'n的十六进制表示.', '10', 'A', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10062', '平均数', '1000', '32768', '0', '0', '给定7个数, 求它们的平均数, 并保留整数.', '一行7个整数, 题目保证求和运算不会超过int范围.', '一个整数, 表示7个数的平均数.', '1 3 5 7 9 8 4', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10063', '找出最大值', '1000', '32768', '0', '0', '给定7个整数, 求出它们的最大值mx, 并输出mx的平方和立方. ', '一行7个整数. 题目保证最大值的立方在int范围内.', '第一行, 输出最大值的平方.\\n第二行, 输出最大值的立方.', '1 3 5 7 9 8 4', '81\r\n729', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10064', '老赵买文具', '1000', '32768', '0', '0', '老赵接到一个任务, 在淘宝店里买尽量多的铅笔.我们已知一只铅笔的价格是a元b角, 老赵的预算是c元d角, 老赵想知道, 他最多能买多少只铅笔呢.', '第一行包括四个整数，依次表示a和b，c和d.', '输出一个整数，表示老赵最多能买多少支铅笔', '1 9\r\n10 3', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10065', '中间的数', '1000', '32768', '0', '0', '给定三个整数x, y, z, 找出三个数中排在中间的数.', '一行三个整数x, y, z(-1e9&lt;=x, y, z&lt;=1e9).', '排在中间的数.', '1 2 3', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10066', '第k小的数', '1000', '32768', '0', '0', '给定一个数组a和一个整数k, 找出数组中第k小的数. (注意, 本题中相等的数看作不同, 比如数列{1, 2, 2, 3}中第3小的数是2而不是3)', '第一行, 两个整数, n(1&lt;=n&lt;=5000000)表示数组的元素个数, k(1&lt;=k&lt;=n).\r\n第二行, 数组中的n个整数(1&lt;=a[i]&lt;=10000).', '输出第k小的数.', '4 3\r\n1 2 2 3', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10067', '硬币问题', '1000', '32768', '0', '0', '假设现在有面值为1, 5, 10, 50, 100, 500的硬币各无限枚, 如果用这些硬币来支付A元, 最少需要多少枚硬币?', '一个整数A(0&lt;=A&lt;=1e9), 表示需要支付的价格.', '输出最少需要的硬币数.', '51', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10068', '区间调度问题', '1000', '32768', '0', '0', '有n项工作, 每项工作的起止时间为[s[i], t[i]]. 对于每项工作, 你都可以选择是否参加, 但是如果参加一项工作后, 就必须在该项工作的起止时间内全程参与, 同一时刻你只能参加一种工作. 问最多可以参加多少项工作. (可以在结束的时刻开始新的工作)', '第一行, 一个正整数n(1&lt;=n&lt;=2000), 表示有多少项工作.\r\n以下n行, 每行两个整数s[i], t[i](1&lt;=s[i]&lt;t[i]&lt;=100000), 表示第1~n项工作的开始和结束时刻.', '输出最多能参加的工作数.', '5\r\n1 3\r\n2 5\r\n4 7\r\n6 9\r\n8 10', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10069', '过河问题', '1000', '32768', '0', '0', 'n个人要过河但是只有一艘一次只能乘坐2个人的船. 每个人划船的速度不同, 船渡河的速度等于船上划船速度最慢的人的速度. 你的任务是找出一个方案, 使所有人渡河, 所用时间最短.', '第一行, 一个整数n(1&lt;=n&lt;=1000).\r\n第二行, n个整数, 范围为[1,100], 表示每个人划船过河所用的时间.', '输出所用的最少时间.', '4\r\n1 2 5 10', '17', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10070', '独木舟', '1000', '32768', '0', '0', '有n个人乘坐独木舟游湖, 每一艘独木舟最多能够承载的重量相同, 并且最多坐两个人. 假设每个人的体重不超过独木舟的承重量, 问最少需要多少独木舟?', '第一行, 两个正整数, n(1&lt;=n&lt;=2000), 表示有几个人, w(1&lt;=w&lt;=1000000), 表示独木舟的承重量.\r\n第二行, n个正整数, 表示每个人的体重, 范围为[1,w].', '输出最少需要的独木舟数量.', '3 6\r\n1 2 3', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10071', '活动安排问题', '1000', '32768', '0', '0', '学校周末要在教室里开展n个活动, 每个活动只能在一间教室进行, 每间教室在一个时刻也最多只能进行一项活动. 现在给定每项活动的开始和结束时间, 最少需要几间教室? (可以在结束的时刻开始新的活动)', '第一行, 一个整数n(1&lt;=n&lt;=2000), 表示有多少项活动.\r\n以下n行, 每一行两个整数l[i], r[i], (1&lt;=l[i]&lt;r[i]&lt;=1e8), 表示每项活动的开始和结束时刻.', '输出最少使用的教室数量.', '3\r\n1 2\r\n3 4\r\n2 9', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10072', '完美字符串', '1000', '32768', '0', '0', '定义一个字符串的完美度为字符串中所有字符的完美度的和. 现在给你一个只含字母的字符串s, 每一个字母的完美度由你进行分配, 可以分配给一个字母[1,26]中的一个数字作为完美度, 但每个字母的完美度必须唯一. 请你计算这个字符串可以达到的最大完美度.', '一个只含英文字母的字符串s(长度不超过100000).', 's最大的完美度.', 'ioi', '77', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10073', '说\\', '1000', '32768', '0', '0', '小明想要用键盘打出&quot;hello&quot;, 但是打错了, 现在已知小明打出的字符串, 请问小明是否可以仅通过删除其中的一些字符, 使这个字符串变成&quot;hello&quot;.', '一个字符串, 长度范围为[1, 1000], 表示打出的字符串, 仅含小写字母.', '如果可以变成&quot;hello&quot;, 输出&quot;YES&quot;, 否则输出&quot;NO&quot;.', 'ahheelloo', 'YES', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10074', '几岁了', '1000', '32768', '0', '0', '假设你今年n岁了, 用英文表示&quot;我今年n岁了&quot;. 比如n=10的情况下, 用英文表示为&quot;I\'m 10 years old.&quot;', '一个整数n(1&lt;=n&lt;=100), 表示你今年几岁.', '按照格式说出你的年龄.', '10', 'I\'m 10 years old.', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10075', '最大回文乘积', '1000', '32768', '0', '0', '给定一个数n, 找出小于n的最大的数x, x是两个三位数的积, 并且x是个回文数.', '一个整数n(101102&lt;=n&lt;=999999).', '输出x.', '101102', '101101', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10076', '去掉重复元素', '1000', '32768', '0', '0', '给定一个整数数组a, 把a中所有重复元素去掉, 并按照递增的顺序输出.', '第一行, 一个整数n(1&lt;=n&lt;=2000), 表示数组元素的个数.\r\n第二行, n个整数(0&lt;=a[i]&lt;=1e9).', '将数组去重后增序输出, 中间用空格隔开.', '4\r\n4 3 3 2', '2 3 4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10077', '最长回文子串', '1000', '32768', '0', '0', '字符串的子串是指字符串中连续的一段, 如&quot;hello&quot;是&quot;helloworld&quot;的一个子串.给定一个字符串s, 找出s的一个子串, 该子串是回文的.', '一个字符串s(1&lt;=|s|&lt;=2000), 仅包含小写字母.', 's的最长子串的长度.', 'acmicpc', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10078', '字符串匹配', '1000', '32768', '0', '0', '给定两个字符串s和t, 计算t在s中出现的次数.', '一行, 两个字符串s, t(1&lt;=|s|&lt;=10000, 1&lt;=|t|&lt;=30), 只含小写字母.', '输出t在s中出现的次数.', 'niconiconi ni', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10079', '相同字母异序词', '1000', '32768', '0', '0', '相同字母异序词(anagram)是指一个单词包含的字母数量相同, 但字母的顺序可能不同, 如&quot;abba&quot;和“baba&quot;是anagram.给定字符串s, 计算一共有多少个子字符串对{x, y}, 其中, x和y是s的一个子串, x和y是相同字母异序词, 并且x和y在s中的位置不同, x在y之前.', '一个字符串s(1&lt;=|s|&lt;=100), 仅含小写字母.', '输出满足条件的子串对数.', 'abba', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10080', '分数拆分', '1000', '32768', '0', '0', '给定一个正整数n, 找出所正整数对(x, y), 使1/k=1/x+1/y 并且x&lt;=y.', '一个正整数k(1&lt;=k&lt;=10000).', '按照&quot;1/k = 1/x + 1/y&quot;的格式输出, 输出顺序使x递增.', '5', '1/5 = 1/6 + 1/30\r\n1/5 = 1/10 + 1/10', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10081', '打印排列', '1000', '32768', '0', '0', '给定一个正整数n, 按照递增顺序打印数字1到n的所有排列. ', '一个整数n(1&lt;=n&lt;=7).', '按照递增的顺序输出n的所有排列, 详见样例.', '3', '1 2 3\r\n1 3 2\r\n2 1 3\r\n2 3 1\r\n3 1 2\r\n3 2 1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10082', '下一个排列', '1000', '32768', '0', '0', '给定一个n个数组成的排列(允许重复元素). 找出这n个数能组成的排列中, 比给定的排序大的最小排列.', '第一行, 一个整数n(1&lt;=n&lt;=1000), 表示元素的个数.\\n第二行, n个正整数(1&lt;=a[i]&lt;=1e9).', '第一行, 如果存在这样的排列, 输出&quot;Yes&quot;, 否则输出&quot;No&quot;.\r\n第二行, 以空格分隔输出找到的排列, 如果不存在, 则输出n个数能够组成的最小排列.', '3\r\n1 2 3', 'Yes\r\n1 3 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10083', '爱丁顿数', '1000', '32768', '0', '0', '英国科学家爱丁顿很喜欢骑车. 据说他为了炫耀自己的骑车功力, 定义了一个&quot;爱丁顿数&quot;E, 表示满足至少有E天骑车路程超过E的最大整数E.现在已知某人n天的骑车距离, 求出他的&quot;爱丁顿数&quot;.', '第一行, 一个整数n(1&lt;=n&lt;=1e5).\r\n第二行, n个正整数.', '输出爱丁顿数.', '5\r\n1 1 2 2 3', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10084', '数\\', '1000', '32768', '0', '0', '给定一个字符串s, 找出在s中有多少种方法可以找出一个三个字符的子序列, 恰好构成&quot;NOI&quot;.例如, NOIOI中, 选择第1, 2, 3位, 第1, 2, 5位, 第1, 4, 5位, 一共三种情况可以组成&quot;NOI&quot;. 注意本题中需要考虑顺序, 比如选择第1, 3, 4位组成的是&quot;NIO&quot;, 不满足条件.', '一行一个字符串s(1&lt;=|s|&lt;=100000), s中只可能包含\'N\', \'O\', \'I\'三种字符.', '一个整数, 表示可以组成&quot;NOI&quot;的方案数, 由于答案可能很大, 最后输出答案除以1000000007的余数.', 'NOIOI', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10085', '最大子段和', '1000', '32768', '0', '0', '数列中一段连续的数被称作子段, 现在给定一个数列, 找出一个子段, 该子段中数的和最大.', '第一行, 一个整数n(1&lt;=n&lt;=2000),表示数组元素的个数.\r\n第二行, n个数(-1e5&lt;=a[i]&lt;=1e5).', '输出最大的子段和, 如果数组中所有元素都是负数, 则输出0.', '5\r\n-1 -2 3 4 -5', '7', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10086', '查找数组元素', '1000', '32768', '0', '0', '给定一个数组, 快速判断是否出现了某个数.', '第一行, 一个整数n(1&lt;=n&lt;=100000), 表示数组元素的个数.\r\n第二行, n个int类型整数, 表示数组的元素, 保证按照非递减的顺序给出.\\n第三行, 一个数字q(1&lt;=q&lt;=100000), 表示查询的个数.\r\n以下q行, 每行一个整数x, 分别代表一个查询.', '对于每个查询, 如果x在数组中出现, 输出&quot;Yes&quot;, 否则输出&quot;No&quot;.', '5\r\n1 3 5 7 9\r\n3\r\n1\r\n2\r\n3', 'Yes\r\nNo\r\nYes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10087', '查找范围', '1000', '32768', '0', '0', '给定一个&lt;b&gt;非递减&lt;/b&gt;数组, 查找一个数在数组中出现的第一个位置和最后一个位置.', '第一行, 一个整数n(1&lt;=n&lt;=100000), 表示数组的元素个数.\r\n第二行, n个整数, 保证非递减.\r\n第三行, 一个整数q(1&lt;=q&lt;=100000), 表示查询的个数.\r\n以下q行, 每行一个整数x, 表示查询的数.', '对于每一个查询x, 如果x在数组中出现, 则输出x出现的第一个位置和最后一个位置, 否则输出&quot;-1 -1&quot;.', '5\r\n1 3 5 7 9\r\n3\r\n1\r\n2\r\n3', '1 1\r\n-1 -1\r\n2 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10088', '数的分解', '1000', '32768', '0', '0', '一个数可以写成几个数的和的形式, 比如4=1+3, 4=2+2. 现在给定一个数n, 计算n可以有多少种分解方法. 分解时右边所有的数都必须是正整数, 至少要有两个数(4=4不算一种分解), 并且数的顺序无关(4=1+3和4=3+1看作同一种方案).', '一个整数n(1&lt;=n&lt;=20).', '输出分解该数的方案数.', '4', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10089', '上台阶', '1000', '32768', '0', '0', '查一查小朋友对于上台阶的方案数特别感兴趣，但是鉴于查一查小朋友现在还不是特别高，所以现在他一步最多跨3个台阶。那么请问，如果有n个台阶，查一查小朋友有多少种不同的上台阶的方案数呢？', '输入有一行一个正整数n，表示有n阶台阶。n&lt;=40。', '一行一个方案数，表示有多少种不同的上台阶的方案。', '3', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10090', '进制转换', '1000', '32768', '0', '0', '给定一个十进制的数, 请把它转成二进制输出.', '一个非负整数x, 保证在int范围内.', '转换成的二进制数.', '2', '10', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10091', '汉诺塔', '1000', '32768', '0', '0', '汉诺塔是根据一个印度传说形成的数学问题:有三根杆子A, B, C. A杆上有n个穿孔圆盘, 盘的尺寸由下到上依次变小. 要求按照下列规则将所有圆盘移至C杆:\r\n1. 每次只能移动一个圆盘\r\n2. 大盘不能叠在小盘上面\r\n找出最少需要移动多少次, 并打印移动的方案.', '一个整数n(1&lt;=n&lt;=15), 表示A杆最初有多少个圆盘.', '第一行, 输出最少移动的次数.\r\n以下每行分别打印一次移动(例如, 移动A杆最上面的圆盘到C杆, 则输出&quot;Move A to C&quot;).', '3', '7\r\nMove A to C\r\nMove A to B\r\nMove C to B\r\nMove A to C\r\nMove B to A\r\nMove B to C\r\nMove A to C', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10092', '快速幂', '1000', '32768', '0', '0', '计算x的e次方, 由于结果可能很大, 对1000000007取模运算后输出.', '一行两个整数x和e, x是正整数, e是非负整数, 同时x和e均在int类型范围内.', 'x的e次方对1000000007取模后的结果.', '2 10', '1024', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10093', '加强版A+B', '1000', '32768', '0', '0', '现在有一个简单的问题，给你两个正整数A和B，你需要计算出A+B的结果。不过要注意哦，这两个正整数非常大。', '输入两个正整数A和B，A和B的位数不超过100000。', '输出A+B，结果占一行。', '12345678909876543210123456789 1', '12345678909876543210123456790', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10094', '大整数排序', '1000', '32768', '0', '0', '对N个长度最长可达到1000的数进行排序。', '输入第一行为一个整数N，(1&lt;=N&lt;=100)。\r\n接下来的N行每行有一个数，数的长度范围为1&lt;=len&lt;=1000。\r\n保证每个数都是一个正数。', '将给出的N个数从小到大进行排序，输出排序后的结果，每个数占一行。', '3\r\n11111111111111111111111111111\r\n2222222222222222222222222222222222\r\n33333333', '33333333\r\n11111111111111111111111111111\r\n2222222222222222222222222222222222', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10095', 'A-B', '1000', '32768', '0', '0', '现在有一个简单的问题，给你两个正整数A和B，你需要计算出A-B。不过要注意哦，这两个正整数非常大。', '输入两个正整数A和B，A和B的位数不超过100000。', '输出A-B，结果占一行。', '12345678909876543210123456789 1', '12345678909876543210123456788', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10096', 'A*B', '1000', '32768', '0', '0', '现在给你一个简单的问题，给你两个正整数A和B，你需要计算出A乘B。不过要注意哦，这A非常大，B是一个两位数。', '输入两个正整数A和B，A的位数不超过10000，B是两位数。', '输出A*B的结果，结果占一行。', '12345678909876543210123456789 11', '135802468008641975311358024679', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10097', '分蛋糕', '1000', '32768', '0', '0', '一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食. ', '每行有两个数p和q.p和q均在int', '输出最少要将蛋糕切成多少块.', '2 3', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10098', '三角形的周长', '1000', '32768', '0', '0', '有n根棍子，棍子i的长度为Ai。现在想要从中选出3根棍子组成周长尽可能长的三角形。请输出最大周长，若无法组成三角形则输出0。', '第一行是一个正整数n(3&lt;=n&lt;=1000000)，代表有n根棍子。\\n第二行有n个正整数，第i个正整数Ai代表第i根棍子的长度。', '如果能组成三角形，则输出最长周长，如果不能组成三角形，输出0。', '5\r\n2 3 4 5 10', '12', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10099', '数组中只出现一次的数字', '1000', '32768', '0', '0', '一个整型数组里除了1个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。', '第一行包含一个整数n，表示数组大小。2&lt;=n &lt;= 10^6。\r\n第二行包含n个整数，表示数组元素，元素均为int。每个数组元素的范围是1~1000000000。', '输出数组中只出现一次的数。输出结果占一行。', '7\r\n2 4 3 3 2 5 5', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10100', '最大整数', '1000', '32768', '0', '0', '设有n个正整数 (n<=100), 将它们连接成一排, 组成一个最大的多位整数.例如: n=3时, 3个整数13, 312, 343连接成的最大整数为: 34331213又如: n=4时, 4个整数7,13,4,246连接成的最大整数为: 7424613\\n\\n', '输入有多组测试数据，对于每组测试数据：\\n第一行是一个正整数n,代表有n个数。\\n第二行包括n个正整数，每个正整数都在int型范围以内。\\n\\n', '输出能拼成的最大整数，每个结果占一行。\\n\\n', '3\\n13 312 343\\n\\n\\n', '34331213\\n\\n\\n', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10101', '丑数', '0', '32768', '0', '0', '把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。', '输入包括一个整数N(1&lt;=N&lt;=1500)。', '输出第N个丑数。', '1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10102', '和为S的连续正数序列', '1000', '32768', '0', '0', '小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!', '输入包括1个整数S(S&lt;=1,000,000)。', '若不存在和为S的连续正数序列,则输出“Pity!”;否则,按照开始数字从小到大的顺序,输出所有和为S的连续正数序列。', '4', 'Pity!', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10103', '简易版之最短距离', '1000', '32768', '0', '0', '寒假的时候想，小明要去拜访很多朋友，恰巧他所有朋友的家都处在坐标平面的X轴上。小明可以任意选择一个朋友的家开始访问，但是每次访问后他都必须回到出发点，然后才能去访问下一个朋友。比如有4个朋友，对应的X轴坐标分别为1， 2， 3， 4。当小明选择坐标为2的点做为出发点时，则他最终需要的时间为 |1-2|+|2-2|+|3-2|+|4-2| = 4。现在给出Ｎ个朋友的坐标，那么ACBOY应该怎么走才会花费时间最少呢？', '输入有2行，首先是一个正整数N（N &lt;= 500)，表示有N个朋友，下一行是N个正整数，表示具体的坐标(所有数据均&lt;=10000).', '请输出访问完所有朋友所花的最少时间，每个输出占一行。', '2 \r\n2 4', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10104', '开关问题', '1000', '32768', '0', '0', '有n盏灯，编号1~n。一开始灯都是关着的，每个灯有一个开关，按奇数次为打开，按偶数次为关闭。我们先把编号为1的倍数的灯按一下开关，再把编号为2的倍数的灯按一下开关，继续把编号为3的倍数的灯按一下开关，依次下去，一直到把编号为n的倍数灯按一下，请问最后有多少盏灯是亮的？ ', '输入为一个整数n(1≤n≤10^9 ) 。', '输出有多少灯是亮的，结果占一行。', '1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10105', '整除的尾数', '1000', '32768', '0', '0', '一个整数，只知道前几位，不知道最后二位，已知它可以被另一个整数整除，那么该数的末二位该是什么呢？', '输入数据包含二个整数a，b（0&lt;a&lt;10000, 10&lt;b&lt;100）。', '将满足条件的所有尾数在一行内输出，格式见样本输出。', '200 40', '00 40 80', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10106', '整数解', '1000', '32768', '0', '0', '有二个整数，它们加起来等于某个整数，乘起来又等于另一个整数，它们到底是真还是假，也就是这种整数到底存不存在，实在有点吃不准，你能快速回答吗？看来只能通过编程。例如：x + y = 9，x * y = 15 ? 找不到这样的整数x和y1+4=5，1*4=4，所以，加起来等于5，乘起来等于4的二个整数为1和4', '输入数据为成对出现的整数n，m（0&lt;n,m&lt;10000），它们分别表示整数的和与积。', '只需要对于每个n和m，输出“Yes”或者“No”，明确有还是没有这种整数就行了。', '9 15', 'No', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10107', '最简真分数', '1000', '32768', '0', '0', '给出n个正整数，任取两个数分别作为分子和分母组成最简真分数，编程求共有几个这样的组合。', '输入包含n（n&lt;=600）和n个不同的整数，整数大于1且小于等于1000。', '每行输出最简真分数组合的个数。', '7\r\n3 5 7 9 11 13 15', '17 ', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10108', '加强版A*B(一)', '1000', '32768', '0', '0', '现在给你一个简单的问题，给你两个正整数A和B，你需要计算出A乘B。不过要注意哦，这A和B都非常大。', '输入两个正整数A和B，A和B的位数均不超过1000。', '输出A*B的结果，结果占一行。', '12345678909876543210123456789 1999999999999999999999999999999999999999999999999', '24691357819753086420246913577999999999999999999987654321090123456789876543211', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10109', '加强版A*B(二)', '1000', '32768', '0', '0', '现在给你一个简单的问题，给你两个正整数A和B，你需要计算出A乘B。不过要注意哦，这A,B非常大。', '输入两个正整数A和B，A的位数不超过50000。', '输出A*B的结果，结果占一行。', '12345678909876543210123456789 1', '12345678909876543210123456789', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10110', 'A除以B', '1000', '32768', '0', '0', '现在给你一个简单的问题，给你两个正整数A和B，你需要计算出A除以B的结果。不过要注意哦，这里的A，B非常大。大到老师提醒你们需要使用高精度来做。', '输入两个正整数A和B，A的位数不超过10000，B的位数不超过100位。', '输出A除B的结果，只保留整数部分，结果占一行。', '12345678909876543210123456789 1', '12345678909876543210123456789', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10111', '大整数开方', '1000', '32768', '0', '0', '输入一个正整数 n（1≤n&lt;10^100），计算它的平方根的整数部分。', '输入一个正整数 n（1≤n&lt;10^100）。', '输出平方根的整数部分。', '5', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10112', '8皇后问题', '1000', '32768', '0', '0', '在国际象棋中，皇后是同时具备象和车的攻击范围的，它可以横竖移动，也可以斜着移动。那么在一个8*8的标准国际象棋棋盘中，我们要放入8个皇后，同时皇后之间无法互相攻击，问有多少种皇后的放置方法。', '没有输入', '一行一个整数，表示放置皇后的方案数。', '无', '无', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10113', 'N皇后问题', '1000', '32768', '0', '0', '在一个N*N的国际象棋棋盘中，放入N个皇后，使得N个皇后无法互相攻击，问有多少种方法。', '一行一个整数N，1&lt;=N&lt;=13', '一行一个整数，表示方案数。', '1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10114', '整数的余数', '1000', '32768', '0', '0', '两个整数a，b如果将a作被除数，b作为除数(不为0)，a除以b的商为c，余数为d，那么我们可以得到如下算式：a = b * c + d同时在实数域中，除数减去余数的绝对值小于除数的绝对值。给定两个整数a，b，问a除以b的余数是多少', '一行两个整数a，b', '一行一个整数，a除以b的余数', '7 -3', '-2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10115', '带分数', '1000', '32768', '0', '0', '100 可以表示为带分数的形式：100 = 3 + 69258 / 714。还可以表示为：100 = 82 + 3546 / 197。注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。类似这样的带分数，100 有 11 种表示法。  ', '输入包括一个正整数N (N&lt;1000000)。', '程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。\\n注意：不要求输出每个表示，只统计有多少表示法！', '100', '11', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10116', '第K小的取法', '1000', '32768', '0', '0', '给定一个含n个数的数组。现在从中取出一些数。并把这些数相加得出一个和，如果有多种取法的和相同，则视为多种取法。求所有取法对应的和中第K小的和。', '第一行包括两个正整数n(1&lt;=20)和k(1&lt;=k&lt;=2^n - 1)。\r\n第二行是n个整数，每个整数保证在int型的范围内。(n个数有负数哦！请尝试绕坑)', '输出第K小的和。结果占一行。', '3 3\r\n1 2 7', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10117', '和为n的等式', '1000', '32768', '0', '0', '给定一个数sum和一个含n个数的数组。现在从中取出一些数。并把这些数相加得出一个和，问和为sum的等式有哪些？每个数组元素最多只能使用一次，要求输出所有满足条件(加数从大到小输出)的等式，并且不能重复。', '第一行包括两个正整数sum(sum&lt;=1000)和n(1&lt;=n&lt;=12)。\r\n第二行是n个正整数，每个正整数的范围是1~100。', '如果不存在等式，则输出一行字符串\'NONE\'。\r\n否则输出满足条件的等式，具体格式见样例', '4 6\r\n4 3 2 2 1 1', '4\r\n3+1\r\n2+2\r\n2+1+1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10118', '木材加工', '1000', '32768', '0', '0', '木材厂有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目是给定的。当然，我们希望得到的小段越长越好，你的任务是计算能够得到的小段木头的最大长度。木头长度的单位是cm。原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。', '第一行是两个正整数N和K(1 ≤ N ≤ 10000，1 ≤ K ≤ 10000)，N是原木的数目，K是需要得到的小段的数目。接下来的N行，每行有一个1到10000之间的正整数，表示一根原木的长度。', '输出能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。', '3 7\r\n232\r\n124\r\n456', '114', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10119', '找第k大的数', '1000', '32768', '0', '0', '给定一个无序正整数序列, 以及另一个数n (1&lt;=n&lt;=1000000), 然后以类似快速排序的方法找到序列中第n大的数（关于第n大的数：例如序列{1，2，3，4，5，6}中第3大的数是4）。', '输入包括两行，第一行包括两个正整数n和k，n代表有n个正整数，k代表要查找第k大的数。\r\n第二行有n个正整数。每个正整数的范围是1~1000000。\\n其中，n的范围是1~1000000，k的范围是1~n', '输出第k大的数。', '6 3\r\n1 2 3 4 5 6', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10120', '字符串替换', '1000', '32768', '0', '0', '给定一个字符串S（S仅包含大小写字母），将S中的每个字母用规定的字母替换，并输出S经过替换后的结果。程序的输入是两个字符串，第一个字符串是给定的字符串S，第二个字符串S’由26个字母组成，它是a-z的任一排列，大小写不定，S’规定了每个字母对应的替换字母：S’中的第一个字母是字母A和a的替换字母，即S中的A用该字母的大写替换，S中的a用该字母的小写替换；S’中的第二个字母是字母B和b的替换字母，即S中的B用该字母的大写替换，S中的b用该字母的小写替换；…… 以此类推。', '输入包括两行，第一行是一个字符串S，第二行是一个字符串S\\\'。S字符串的长度不大于10000。', '输出替换后的字符串。', 'abbccdd\r\ncdbaefghijklmnopqrstuvwxyz', 'cddbbaa', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10121', '国王放置', '1000', '32768', '0', '0', '在n*m的棋盘上放置k个国王，要求k个国王互相不攻击，有多少种不同的放置方法。假设国王放置在第(x,y)格，国王的攻击的区域是:(x-1,y-1), (x-1,y),(x-1,y+1),(x,y-1),(x,y+1),(x+1,y-1),(x+1,y),(x+1,y+1)。', '输入包括三个数n,m,k，(0&lt;n,m&lt;=5,0&lt;k&lt;=n*m)含义如题面。', '输出不同的放置方法，每个结果占一行。', '4 4 4', '79', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10122', '最大连续子段和', '1000', '32768', '0', '0', '给出一个数列（元素个数不多于100），数列元素均为负整数、正整数、0。请找出数列中的一个连续子数列，使得这个子数列中包含的所有元素之和最大，在和最大的前提下还要求该子数列包含的元素个数最多，并输出这个最大和以及该连续子数列中元素的个数。', '输入包括两行，第一行为一个正整数n，代表有n个正整数。\r\n第二行包括n个整数。每个整数的范围是-1000000~1000000。', '输出最大和以及该连续子数列中元素的个数。这两个数之间用空格隔开，每结果占一行。', '5\r\n4 -5 3 2 4', '9 3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10123', '哥德巴赫猜想', '1000', '32768', '0', '0', '哥德巴赫猜想是指，任一大于2的偶数都可写成两个质数之和。迄今为止，这仍然是一个著名的世界难题，被誉为数学王冠上的明珠。试编写程序，验证任一大于2且不超过n的偶数都能写成两个质数a和b之和。', '输入一个正整数n。(4&lt;=n&lt;=100000)', '输出a和b，要满足a&lt;=b，如果有多种组合满足要求，则输出a最小的那个组合。', '6', '3 3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10124', '子矩阵', '1000', '32768', '0', '0', '输入一个 n1*m1 的矩阵 a，和 n2*m2 的矩阵 b，问 a 中是否存在子矩阵和 b 相等。 若存在， 输出所有子矩阵左上角的坐标； 若不存在输出 “There is no answer” 。 ', '第一行是n1,m1。\r\n然后接下来的n1行是n1*m1的矩阵。\r\n紧接着是n2,m2。\r\n最后n2行是n2*m2的矩阵。\r\n其中，n1,m1,n2,m2的范围都是1~50。每个矩阵元素的范围都是int型范围内。', '输出所有子矩阵左上角的坐标，输出顺序见样例。', '5 5\r\n1 0 0 1 0\r\n0 1 0 1 0\r\n1 1 0 0 1\r\n1 0 1 1 0\r\n0 0 0 0 1\r\n2 2\r\n1 0\r\n0 1', '1 1\r\n2 4\r\n3 2\r\n4 4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10125', '排列数', '1000', '32768', '0', '0', '输入两个正整数 n，m（1&lt;n&lt;20,1&lt;m&lt;min(n,5)），在 1~n 中任取 m 个数，按字典序从小到大输出所有这样的排列。', '输入两个正整数n,m。', '输出所有排列。', '3 2', '1 2\r\n1 3\r\n2 1\r\n2 3\r\n3 1\r\n3 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10126', '坐标统计', '1000', '32768', '0', '0', '输入 n 个整点在平面上的坐标。对于每个点，可以控制所有位于它左下方的点（即 x、y 坐标都比它小），它可以控制的点的数目称为“战斗力”。依次输出每个点的战斗力，最后输出战斗力最高的点的编号（如果若干个点的战斗力并列最高，输出其中最大的编号）。', '输入的第一行是一个正整数n。(1=&lt;n&lt;=100)\\n接下来n行是n个点的坐标。每个坐标的范围都在int型范围之内。', '依次输出每个点的战斗力，最后输出战斗力最高的点的编号。', '5\r\n1 2\r\n3 4\r\n5 6\r\n7 8\r\n9 10', '0\r\n1\r\n2\r\n3\r\n4\r\n4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10127', '二叉查找树', '1000', '32768', '0', '0', '二叉查找树具有如下性质：每个节点的值都大于其左子树上所有节点的值、小于其右子树上所有节点的值。试判断一棵树是否为二叉查找树。', '输入的第一行包含一个整数 n（n&lt;=5000），表示这棵树有 n 个顶点，编号分别为 1, 2, …, n，其中编号为 1 的为根结点。之后的第 i 行有三个数 value, left_child, right_child，分别表示编号为i的节点的关键字的值、左子节点的编号、右子节点的编号。', '如果不存在左子节点或右子节 点，则用 0 代替。输出 1 表示这棵树是二叉查找树，输出 0 则表示不是。', '5\r\n7 2 3\r\n5 4 5\r\n9 0 0\r\n2 0 0\r\n6 0 0', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10128', '序列重排', '1000', '32768', '0', '0', '全局数组变量 a 定义如下：#define SIZE 100 int a[SIZE], n;它记录着一个长度为 n 的序列 a[1], a[2], …, a[n]。现在需要一个函数，以整数 p (1 ≤ p ≤ n)为参数，实现如下功能：将序列 a 的前 p 个数与后 n – p 个数对调，且不改变这 p 个数（或 n – p 个数）之间的相对位置。例如，长度为 5 的序列 1, 2, 3, 4, 5，当 p = 2 时重排结果为 3, 4, 5, 1, 2。', '第一行包括两个正整数n和p。(0&lt;n&lt;=100,0&lt;p&lt;=n)\\n接下来的一行包括n个正整数。每个正整数的范围是1~100', '输出重排之后的数组。', '5 2\r\n1 2 3 4 5', '3 4 5 1 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10129', '数字删除', '1000', '32768', '0', '0', '将字符串中的数字字符删除后输出。', '输入一个长度不超过1000000的字符串。字符串中包括大小写字母以及字符串。', '输出删除了数字字符之后的字符串。', 'Abc35f6wwoo9', 'Abcfwwoo', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10130', '最大子矩阵和', '1000', '32768', '0', '0', '给出m行n列的整数矩阵，求最大的子矩阵和（子矩阵不能为空）。 输入第一行包含两个整数m和n，即矩阵的行数和列数。之后m行，每行n个整数，描述整个矩阵。程序最终输出最大的子矩阵和。', '第一行包括两个正整数n,m。(0&lt;n,m&lt;=100)\\n接下来的n行是一个n*m的矩阵。矩阵的每个元素都在int型范围之内。', '输出最大的子矩阵和。', '4 4\r\n0 -2 -7 0\r\n9 2 -6 2\r\n-4 1 -4  1\r\n-1 8  0 -2', '15', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10131', '中位数', '1000', '32768', '0', '0', '给定 n（n 为奇数且小于 1000）个整数，整数的范围在 0~m（0 &lt; m &lt; 2^31 ）之间，请使用二分法求这 n 个整数的中位数。所谓中位数，是指将这 n 个数排序之后，排在正中间的数。', '第一行包括两个正整数n和m。(0&lt;n&lt;1000,且n为奇数)\r\n第二行是n个正整数，每个正整数的范围都是int型。', '输出中位数，结果占一行。', '5 9\r\n3 2 6 1 9', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10132', '实数取模', '1000', '32768', '0', '0', '给定两个实数a,b，计算a对b取模的结果。a,b均为非负，b不为0.', '输入只有一行，包括两个实数a,b，均在double型范围内，数据保证b不为0。', '输出取模的结果，结果保留两位小数，每个结果占一行。', '1.5 0.3', '0.00', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10133', '排序排序', '1000', '32768', '0', '0', '有N个整数放在lyc小朋友的面前，可惜lyc小朋友有强迫症，因此他需要将这N个整数按照从小到大的顺序重新排列起来，由于lyc小朋友比较懒，因此他希望你来帮助他实现。', '第一行一个整数N(N&lt;=2000)，表示有N个整数需要排序\\n接下来一行有N个整数ai(1&lt;=ai&lt;=1e9)，分别表示摆在lyc小朋友面前的N个整数。', '一行N个整数，表示排序后的结果。', '5\r\n5 4 2 1 3', '1 2 3 4 5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10134', '序排序排', '1000', '32768', '0', '0', '有N个整数放在lyc小朋友的面前，可惜lyc小朋友有强迫症，因此他需要将这N个整数按照从大到小的顺序重新排列起来，由于lyc小朋友比较懒，因此他希望你来帮助他实现。', '第一行一个整数N(N&lt;=2000)，表示有N个整数需要排序\\n接下来一行有N个整数ai(1&lt;=ai&lt;=1e9)，分别表示摆在lyc小朋友面前的N个整数。', '一行N个整数，表示排序后的结果。', '5\r\n1 3 2 4 5', '5 4 3 2 1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10135', '排排序序', '1000', '32768', '0', '0', '有N个整数放在lyc小朋友的面前，可惜lyc小朋友有强迫症，因此他需要将这N个整数按照从小到大的顺序重新排列起来，由于lyc小朋友比较懒，因此他希望你来帮助他实现。', '第一行一个整数N(N&lt;=10000000)，表示有N个整数需要排序\\n接下来一行有N个整数ai(1&lt;=ai&lt;=1e4)，分别表示摆在lyc小朋友面前的N个整数。', '一行N个整数，表示排序后的结果。', '5\r\n1 1 2 4 3', '1 1 2 3 4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10136', '序序排排', '1000', '32768', '0', '0', '有N个整数放在lyc小朋友的面前，可惜lyc小朋友有强迫症，因此他需要将这N个整数按照从小到大的顺序重新排列起来，由于lyc小朋友比较懒，因此他希望你来帮助他实现。', '第一行一个整数N(N&lt;=1000000)，表示有N个整数需要排序\\n接下来一行有N个整数ai(1&lt;=ai&lt;=1e9)，分别表示摆在lyc小朋友面前的N个整数。', '一行N个整数，表示排序后的结果。', '5\r\n5 4 3 2 1', '1 2 3 4 5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10137', '24点', '1000', '32768', '0', '0', '24点游戏是一个这样的规则，给定4个整数，只允许在4个整数之间添加+,-,*,/这4种运算符，在不忽视运算优先级的前提下，使表达式的值为24.（不允许改变4个整数的位置）现在给定4个整数，问有多少种添加运算符的方法，使得表达式最后的结果为24.4个整数均为正整数。', '一行4个整数，如题。', '一行一个方案数，表示有多少种方法使得最后的表达式值为24.', '1 1 12 12', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10138', '平均值', '1000', '32768', '0', '0', '这是一道水题，给你7个整数，请你求出这7个整数的平均值，并且保留整数。', '一行7个整数。\r\n数据范围：\r\n保证7个整数的和在32位整数范围内。', '一行一个整数，表示7个数的平均值。', '1 3 5 7 9 8 4', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10139', '最大值', '1000', '32768', '0', '0', '这是一道水题，给你7个整数，请你求出这7个整数中的最大值，并且输出他的平方和他的立方。\r\n数据范围：保证7个数中最大值的立方在32位整数范围内。', '一行7个整数', '第一行1个整数，表示最大值的平方\r\n第二行1个整数，表示最大值的立方', '1 3 5 7 9 8 4', '81\r\n729', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10140', '倒序', '1000', '32768', '0', '0', '这是一道水题，给你N个整数，请你将它们以相反的顺序输出。', '第一行一个整数，表示N。\r\n接下来一行有N个整数。\r\n数据范围：\\nN&lt;=10000', '一行N个整数，表示倒序输出的结果。', '5\r\n2 4 6 7 3\r\n', '3 7 6 4 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10141', '津津的储蓄计划', '1000', '32768', '0', '0', '津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20％还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。', '输入文件包括12行数据，每行包含一个小于350的非负整数，分别表示1月到12月津津的预算。', '输出文件包括一行，这一行只包含一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出-X，X表示出现这种情况的第一个月；否则输出到2004年年末津津手中会有多少钱。', '290\r\n230\r\n280\r\n200\r\n300\r\n170\r\n340\r\n50 \r\n90 \r\n80 \r\n200\r\n60', '-7', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10142', '胖源的随机数', '1000', '32768', '0', '0', '胖源想知道计算机跑出来的随机数是不是真的，因此决定做一个实验，如果计算机随机出N个整数没有重复的话，那么胖源就会认为计算机跑出来的随机数是真的，否则为假。但是胖源随机出了N个整数后，决定去吃一份（广告位招租），因此这个重任便落到你的身上了。', '第一行一个整数N\r\n接下来N行，每行一个整数（小于100）', '一行yes或者no，如果是真随机数，输出yes，否则输出no。', '7\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n1', 'no', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10143', '奇数', '1000', '32768', '0', '0', '这是一道水题，给一个整数N，请你求出所有不大于N的奇数。按照从小到大的顺序输出。', '一行一个整数N。数据范围：N&lt;=100。', '若干行，每行一个整数。', '8', '1\r\n3\r\n5\r\n7', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10144', '最大公约数', '1000', '32768', '0', '0', '约数，又称因数。整数a除以整数b没有余数，我们就说a能被b整除，b称为a的约数。a % b = 0，则b是a的约数，%是取余的意思）如果存在一个b，使得a % b = 0,c % b = 0，则称b是a和c的公约数。给定a，c求它们的最大公约数。', '一行两个整数，分别表示a，c。保证a，c在32位整数范围内。', '一行一个整数，表示a，c的最大公约数', '24 16', '8', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10145', 'Cantor表', '1000', '32768', '0', '0', '现代数学的著名证明之一是Georg Cantor证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：\r\n　　1/1  1/2  1/3  1/4 1/5 …\r\n　　2/1  2/2  2/3  2/4…\r\n　　3/1  3/2  3/3 …\r\n　　4/1  4/2 …\r\n　　5/1 …\r\n　　…\r\n　　我们以Z字形给上表的每一项编号。第一项是1/1，然后是1/2，2/1，3/1，2/2，…\r\n给定一个整数N，请你求出Cantor表中第N项是多少。', '一行一个整数N。数据范围：N&lt;=1000。', '一行一个分数，表示第N项是多少。', '7', '1/4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10146', 'ISBN号码', '1000', '32768', '0', '0', '每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”就是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。\r\n识别码的计算方法如下：首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，...,9,再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。\r\n    你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出你认为是正确的ISBN号码。', '只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。', '共一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。', '0-670-82162-4', 'Right', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10147', '税收计算', '1000', '32768', '0', '0', '根据国家个人所得税现行方法，给出以下计算计算个人所得税，首先每个月取得工资收入，减去3500元，剩下的就是应纳税所得额。个人所得税的方法计算如下表所示：\r\n级数   含税级距                                  税率(%)   \r\n1       不超过1500元的                          3 \r\n2       超过1500元至4500元的部分       10 \r\n3       超过4500元至9000元的部分       20 \r\n4       超过9000元至35000元的部分     25 \r\n5       超过35000元至55000元的部分   30 \r\n6       超过55000元至80000元的部分   35 \r\n7       超过80000元的部分                    45 \r\n\r\n        给定老赵一个月的工资（整数），问老赵每月应交个人所得税是多少？', '一行1个整数，表示老赵一个月的收入。', '一行1个整数，表示老赵一个月需要交纳的个人所得税，保留两位小数。', '6000', '145.00', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10148', '中国剩余定理', '1000', '32768', '0', '0', '有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何。\r\n        子曰：二十三。\r\ntcoi曰：此数大于a，问物几何？（是大于，而不是大于等于）', '一个整数a，如题所示。', '一个正整数b，b是大于a，且符合剩余定理的最小正整数。', '23', '128', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10149', '奶牛的数字游戏', '1000', '32768', '0', '0', '奶牛们又在玩一种无聊的数字游戏。输得很郁闷的dcq想请你写个程序来帮他在开局时预测结果。\r\n在游戏的开始，每头牛都会得到一个数N(1&lt;=N&lt;=1,000,000)。此时奶牛们的分数均为0。如果N是奇数，那么奶牛就会把它乘以3后再加1。如果N是偶数，那么这个数就会被除以2。数字每变动一次，这头奶牛就得到1分。当N的值等于1时，游戏结束，此时的分数就是这头奶牛在这局游戏中的最终得分。\r\n \r\n以下是N的初始值为5时，一局游戏的完整过程：\r\nN 操作后所得数    注释    总分 \r\n         5                   16       5*3+1=16 1 \r\n        16                   8       16/2=8 2 \r\n         8                    4        8/2=4 3 \r\n         4                    2        4/2=2 4 \r\n         2                    1        2/2=1 5 \r\n\r\n这头奶牛的最终得分是5。', '一行一个整数N。数据范围：N&lt;=1000000。', '一行一个整数，表示这头奶牛的得分。', '5', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10150', '分解质因数', '1000', '32768', '0', '0', '任何一个整数都可以分解为几个质数的乘积，例如12=2*2*3，2和3不仅是12的因子，同时也都是质数。所以2和3就是12的质因子。将12完全分解为质因子的乘积，就称为分解质因数。\r\n现在问题来了，给定任意一个正整数，请你将它分解质因数，并按照要求的格式输出。', '一行一个正整数。\r\n数据范围：\r\n保证数据在32位整数范围内。\r\n保证非1。', '一行一个分解后的结果，格式请参照样例输出。', '12', '12=2*2*3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10151', '梦回幼儿园', '1000', '32768', '0', '0', '这是一个真实的故事。\r\n2013年12月，一道惊天的幼儿园的智力题，被发布在网上。据说研究生用了微积分+￥#……%@￥￥%#￥……也没算出。\r\n这道题目看上去很简单：\r\n7111=0\r\n8809=6\r\n2172=0\r\n6666=4\r\n1111=0\r\n2222=0\r\n7662=2\r\n9313=1\r\n0000=4\r\n5555=0\r\n8193=3\r\n8096=5\r\n4398=3\r\n9475=1\r\n9038=4\r\n3148=2', '一行一个四位数。数据范围：保证输入合法，是一个四位数，且第一位不会是0。', '一行，这道幼儿园智力题的答案。', '2889', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10152', 'lyq的泡面', '1000', '32768', '0', '0', 'lyq对于泡面情有独钟，于是准备去买泡面。\r\n店铺里的泡面被放成了一排，每一块泡面都有一个独立的价钱。lyq打算买很多碗泡面，但是为了节约时间，她会选择买连续的几碗泡面，这样比较省时间。\r\nlyq的大脑中已经全是泡面的样子了，智商堪忧，因此无法计算价钱了。所以你的任务是帮lyq计算连续的几碗泡面需要多少钱，lyq可能会多次询问你。', '第一行一个整数N，表示商店里有N碗泡面\r\n接下来一行，有N个整数，表示N碗泡面的价钱。\r\n接下来一行，一个整数M，表示lyq询问你的次数\r\n接下来M行，每行两个整数a,b，表示lyq想问你第a碗到第b碗泡面的总价钱是多少。\r\n数据范围：\r\n对于50%的数据 N&lt;=1000，M&lt;=100\r\n对于100%的数据 N &lt;= 1000000，M&lt;=1000000\r\n保证输入合法。', 'M行，每行一个整数，表示对于每次询问，几碗连续的泡面的总价钱。', '8\r\n1 3 5 7 2 4 8 6\r\n3\r\n1 4\r\n2 7\r\n6 8', '16\r\n29\r\n18', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10153', '数组中只出现奇数次的数字', '1000', '32768', '0', '0', '一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现奇数次的数字。', '第一行包含一个整数n，表示数组大小。2&lt;=n &lt;= 5*10^6。\r\n第二行包含n个整数，表示数组元素，元素均为int。', '按从小到大的顺序输出这两个数，结果占一行。', '2\r\n1 2', '1 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10154', '变态跳台阶', '1000', '32768', '0', '0', '一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。', '输入包括一个整数n(1&lt;=n&lt;=50)。', '输出该青蛙跳上一个n级的台阶总共有多少种跳法。', '3', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10155', '部分错排问题', '1000', '32768', '0', '0', '国庆期间,省城HZ刚刚举行了一场盛大的集体婚礼,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做&quot;考新郎&quot;,具体的操作是这样的:首先,给每位新娘打扮得几乎一模一样,并盖上大大的红盖头随机坐成一排;然后,让各位新郎寻找自己的新娘.每人只准找一个,并且不允许多人找一个.最后,揭开盖头,如果找错了对象就要当众跪搓衣板...看来做新郎也不是容易的事情...假设一共有N对新婚夫妇,其中有M个新郎找错了新娘,求发生这种情况一共有多少种可能.', '每行包含两个整数N和M(1&lt;M&lt;=N&lt;=20)。', '请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。', '3 2', '3', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10156', '抽签', '1000', '32768', '0', '0', '你的一位朋友提议玩一个游戏：将写有数字的n个纸片放入口袋，你可以从口袋中抽取4次纸片，每次记下纸片上的数字后都将其放回口袋中。如果这四个数字的和是m，就是你赢，否则就是你的朋友赢。你挑战了好几回，结果一次也没赢过，于是怒而撕破口袋，取出所有纸片，检查自己是否真的有赢的可能性。请你编一个程序，判断当纸片上所写的数字是K1,K2,K3...Kn时，是否存在抽取四次和为m的方案。如果存在，输出Yes；否则，输出No。', '第一行，一个整数n。(1&lt;=n&lt;=1000)\r\n第二行，一个整数m。(1&lt;=m&lt;=10^8)\r\n第三行，n个整数Ki。(1&lt;=Ki&lt;=10^8)', '如果存在，输出Yes；否则，输出No。结果占一行。', '3\r\n10\r\n1 3 5', 'Yes', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10157', '骨牌铺方格', '1000', '32768', '0', '0', '在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数.例如n=3时,为2× 3方格，骨牌的铺放方案有三种,如下图：', '每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n (0&lt;n&lt;=50)。', '请输出铺放方案的总数，每个实例的输出占一行。', '1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10158', '货币面值', '1000', '32768', '0', '0', '小虎是游戏中的一个国王，在他管理的国家中发行了很多不同面额的纸币，用这些纸币进行任意的组合可以在游戏中购买各种装备来提升自己。有一天，他突然很想知道这些纸币的组合不能表示的最小面额是多少，请聪明的你来帮助小虎来解决这个财政问题吧。', '第一行输入一个整数N（N&lt;=1000000）表示流通的纸币面额数量，第二行是N个纸币的具体表示面额，取值[1，1000000000]。', '输出一个整数，表示已经发行的所有纸币都不能表示的最小面额（已经发行的每个纸币面额最多只能使用一次,但面值可能有重复）。', '5\r\n1 2 3 9 100', '7', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10159', '买不到的数目', '1000', '32768', '0', '0', '小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。如果不存在，则输出-1。', '两个正整数，表示每种包装中糖的颗数(都不多于1000000000)。', '一个正整数，表示最大不能买到的糖数。', '4 7', '17', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10160', '首尾相连数组的最大子数组和', '1000', '32768', '0', '0', '给定一个由N个整数元素组成的数组arr，数组中有正数也有负数，这个数组不是一般的数组，其首尾是相连的。数组中一个或多个连续元素可以组成一个子数组，其中存在这样的子数组arr[i],…arr[n-1],arr[0],…,arr[j]，现在请你这个OI_Lover用一个最高效的方法帮忙找出所有连续子数组和的最大值（如果数组中的元素全部为负数，则最大和为0，即一个也没有选）。', '每个测试用例共有两行，第一行是一个整数n（1=&lt;n&lt;=1000000），表示数组的长度，第二行依次输入n个整数（整数绝对值不大于100）。', '请输出子数组和的最大值。', '6\r\n1 -2 3 5 -1 2', '10', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10161', '寻找路线', '1000', '32768', '0', '0', '小明在A点，他要到B点。从A到B有许多交错的路， 这些交错的路形成了有很多1*1的小正方形组成的长方形，长为l，宽为w。 他想知道A点到B点有几条最短路线可走。', '两个正整数l和w（0 &lt; w &lt;= l &lt;= 33）。', 'A点到B点的 最短路线的条数。', '3 2', '10', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10162', '猜数字', '1000', '32768', '0', '0', '输入一个数字n(0 <= n <= 32768), 利用二分法猜到这个数字. \\n\\n', '一个数字n\\n\\n', '一共若干行, 一行两个数, 第一个数为猜的次数, 第二个数为猜的数字.\\n\\n', '24687\\n\\n', '1 16384\\n2 24576\\n3 28672\\n4 26624\\n5 25600\\n6 25088\\n7 24832\\n8 24704\\n9 24640\\n10 24672\\n11 24688\\n12 24680\\n13 24684\\n14 24686\\n15 24687\\n\\n', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10163', '打印日历 (2)', '1000', '32768', '0', '0', '已知2010-1-1是星期五, 给出年份与月份, 按照下列格式打印这个月的日历:\r\n\r\n月份是{&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;};\r\n\r\nMarch 2016\r\n\r\nSun     Mon     Tue     Wed     Thu     Fri     Sat\r\n\r\n                1       2       3       4       5\r\n\r\n6       7       8       9       10      11      12\r\n\r\n13      14      15      16      17      18      19\r\n\r\n20      21      22      23      24      25      26\r\n\r\n27      28      29      30      31\r\n\r\n用Sun,  Mon, Tues, Wed, Thur, Fri, Sat表示星期日到星期六.', '两个整数(y, m), 其中y(1900 &lt;= n &lt;= 2099)表示年份, m(1&lt;=m&lt;=12)表示月份.', '第一行, 打印星期天到星期六的符号.\r\n第二行开始, 依次打印每一天的日期.\r\n打印时使用制表符\'\\t\'间隔(如果1号不是星期天, 那么需要在第二行前添加\'\\t\'缩进), 每一行最后不要打印多余的制表符. 注意最后一天之后也是直接换行, 不要打印多余的制表符.', '2016 3', 'March 2016\r\nSun     Mon     Tue     Wed     Thu     Fri     Sat\r\n                1       2       3       4       5\r\n6       7       8       9       10      11      12\r\n13      14      15      16      17      18      19\r\n20      21      22      23      24      25      26\r\n27      28      29      30      31', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10164', '二次方程', '1000', '32768', '0', '0', '给出一个二次方程, 求出二次方程的解.', '一个二次方程, 以&quot;a*x^2+b*x+c=0&quot;的格式输入. 其中a, b为系数, c为常数项. 变量名称为一个字母, 只能有一个变量. 等号右边只能是0. a!=0. 要是不符合要求, 输出&quot;Input error!&quot;(不包含引号).', '二次方程的解.\r\n若有2个不同的解, 输出\r\nx1=...\r\nx2=... (假设变量名称为x)\r\n\r\n若有2个相同的解, 输出\r\nx=...\r\n\r\n若2个解为复数, 输出\r\nx1=a+b*i\r\nx2=a-b*i (x1, x2的顺序不能改变. a, b不是二次方程的系数)\r\n\r\n若方程格式错误, 输出\r\nInput error!\r\n\r\n均保留6位小数.', '1*x^2+1*x-6=0', 'x1=2.000000\r\nx2=-3.000000', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10165', '倒序输出', '1000', '32768', '0', '0', '给定两个数字N，M，递减打印最大的N位数到1的前M个数，例如给定2 5，则打印99 98 97 96 95。', '输入一个数字n,m。(n&lt;=10^3,1&lt;=m&lt;=min(10^n,10^3))', '依次递减打印最大的N位数的前m个数，每个数都占一行。', '1 9', '9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10166', '翻硬币', '1000', '32768', '0', '0', '小明正在玩一个“翻硬币”的游戏。桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。比如，可能情形是：**oo***oooo如果同时翻转左边的两个硬币，则变为：oooo***oooo现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？', '两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;5000000', '一个整数，表示最小操作步数，如果无法做到则输出“NO”。', '**********\r\no****o****', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10167', '方阵取数', '1000', '32768', '0', '0', '给出一个n*n的方阵，每个元素为整数。在这n*n的矩阵中取出n个元素，这n个元素中的任意两个元素既不能在同一行，也不能在同一列。求取出的这n个数的和的最大值。', '第一行是一个整数n,表示接下来会给出n*n的方阵\r\n接下来有n行，每行有n列。\r\n方阵每个元素的范围是[1,10^9],n的范围是[1,14]。', '输出每个方阵取出n个数的和的最大值。', '3\r\n1 2 3\r\n4 6 5\r\n9 7 8', '18', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10168', '汉诺塔II', '0', '32768', '0', '0', '经典的汉诺塔问题经常作为一个递归的经典例题存在。可能有人并不知道汉诺塔问题的典故。汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘。有预言说，这件事完成时宇宙会在一瞬间闪电式毁灭。也有人相信婆罗门至今仍在一刻不停地搬动着圆盘。恩，当然这个传说并不可信，如今汉诺塔更多的是作为一个玩具存在。Gardon就收到了一个汉诺塔玩具作为生日礼物。 　　Gardon是个怕麻烦的人（恩，就是爱偷懒的人），很显然将64个圆盘逐一搬动直到所有的盘子都到达第三个柱子上很困难，所以Gardon决定作个小弊，他又找来了一根一模一样的柱子，通过这个柱子来更快的把所有的盘子移到第三个柱子上。下面的问题就是：当Gardon在一次游戏中使用了N个盘子时，他需要多少次移动才能把他们都移到第三个柱子上？很显然，在没有第四个柱子时，问题的解是2^N-1，但现在有了这个柱子的帮助，又该是多少呢？', '包含多组数据，每个数据一行，是盘子的数目N(1&lt;=N&lt;=64)。', '对于每组数据，输出一个数，到达目标需要的最少的移动数。', '1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10169', '后a位数', '1000', '32768', '0', '0', '输入两个整数，输出x^y的后a位数。', '数据包含3个正整数x,y,a。(1&lt;=x&lt;=10^10000，1&lt;=y&lt;=10^9,1&lt;=a&lt;=9)。', '输出x^y的后a位数,不足a位用0补齐，每个结果占一行。', '2 1 1', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10170', '矩阵翻转', '1000', '32768', '0', '0', 'Ciel有一个N*N的矩阵，每个格子里都有一个整数。N是一个奇数，设X = (N+1)/2。Ciel每次都可以做这样的一次操作：他从矩阵选出一个X*X的子矩阵，并将这个子矩阵中的所有整数都乘以-1。现在问你经过一些操作之后，矩阵中所有数的和最大可以为多少。', '第一行为一个正整数N。\r\n接下来N行每行有N个整数，表示初始矩阵中的数字。每个数的绝对值不超过1000。\r\n数据规模与约定\r\n1 &lt;= N &lt;= 33，且N为奇数。', '输出一个整数，表示操作后矩阵中所有数之和的最大值。', '3\r\n-1 -1 1\r\n-1 1 -1\r\n1 -1 -1', '9', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10171', '绝对值排序', '1000', '32768', '0', '0', '输入n(n&lt;=1000000)个整数，按照绝对值从大到小稳定排序后输出。', '每行的第一个数字为n,接着是n个整数,每个整数均在int型的范围内。', '输出排序后的结果，两个数之间用一个空格隔开。结果占一行。', '3 3 -4 2', '-4 3 2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10172', '数组中第K小的数字', '1000', '32768', '0', '0', '给定两个整型数组A和B。我们将A和B中的元素两两相加可以得到数组C。譬如A为[1,2]，B为[3,4].那么由A和B中的元素两两相加得到的数组C为[4,5,5,6]。现在给你数组A和B，求由A和B两两相加得到的数组C中，第K小的数字。', '输入的第一行为三个整数m，n， k(1&lt;=m,n&lt;=100000， 1&lt;= k &lt;= n *m)：n，m代表将要输入数组A和B的长度。\r\n紧接着两行， 分别有m和n个数， 代表数组A和B中的元素。数组元素范围为[0,1e9]。', '输出由A和B中元素两两相加得到的数组c中第K小的数字。', '2 2 3\r\n1 2\r\n3 4', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10173', '折线分割平面', '1000', '32768', '0', '0', '我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。', '每行包含一个整数n(0&lt;n&lt;=10000),表示折线的数量。', '请输出平面的最大分割数，每个实例的输出占一行。', '1', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10174', '最大值最小化', '1000', '32768', '0', '0', '在印刷术发明之前，复制一本书是一个很困难的工作，工作量很大，而且需要大家的积极配合来抄写一本书，团队合作能力很重要。当时都是通过招募抄写员来进行书本的录入和复制工作的, 假设现在要抄写m本书，编号为1,2,3...m, 每本书有1&lt;=x&lt;=100000页， 把这些书分配给k个抄写员，要求分配给某个抄写员的那些书的编号必须是连续的，每本书只能被一个抄写员抄写。每个抄写员的速度是相同的，你的任务就是找到一个最佳的分配方案，使得所有书能够被抄完的前提下，每个抄写员所抄写的页数最少。', '在第一行中，有两个整数m和 k， 1&lt;=k&lt;=m&lt;=500。 在第二行中，有m个整数xi用空格分隔。 所有这些值都为正且小于100000。', '输出一行数字，代表最佳的分配方案全部抄写完毕每个抄写员所抄写的页数。', '9 3\r\n100 200 300 400 500 600 700 800 900', '1700', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10175', '搬水果', '1000', '32768', '0', '0', '在一个果园里，小明已经将所有的水果打了下来，并按水果的不同种类分成了若干堆，小明决定把所有的水果合成一堆。每一次合并，小明可以把两堆水果合并到一起，消耗的体力等于两堆水果的重量之和。当然经过 n‐1 次合并之后，就变成一堆了。小明在合并水果时总共消耗的体力等于每次合并所耗体力之和。    假定每个水果重量都为 1，并且已知水果的种类数和每种水果的数目，你的任务是设计出合并的次序方案，使小明耗费的体力最少，并输出这个最小的体力耗费值。例如有 3 种水果，数目依次为 1，2，9。可以先将 1，2 堆合并，新堆数目为3，耗费体力为 3。然后将新堆与原先的第三堆合并得到新的堆，耗费体力为 12。所以小明总共耗费体力=3+12=15，可以证明 15 为最小的体力耗费值。', '输入的第一行是一个整数 n(1&lt;=n&lt;=10000),表示水果的种类数。第二行包含 n 个整数，用空格分隔，第 i 个整数(1&lt;=ai&lt;=1000)是第 i 种水果的数目。', '输出一个整数并换行，这个值也就是最小的体力耗费值。输入数据保证这个值小于 2^31。', '3\r\n9 1 2', '15', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10176', '分糖果', '1000', '32768', '0', '0', '给从左至右排好队的小朋友们分糖果，要求：1.每个小朋友都有一个得分，任意两个相邻的小朋友，得分较高的所得的糖果必须大于得分较低的，相等则不作要求。2.每个小朋友至少获得一个糖果。求，至少需要的糖果数。', '输入由一个整数n（1&lt;=n&lt;=1000000）开头，接下去一行包含n个整数，代表每个小朋友的分数Si（1&lt;=Si&lt;=10000）。', '输出一个整数，代表至少需要的糖果数。', '3\r\n1 10 1', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10177', 'N！', '1000', '32768', '0', '0', '给定一个N，你的任务是计算N！', '一个N。(0&lt;=N&lt;=10000)', 'N！', '1', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10178', '高精度取模', '1000', '32768', '0', '0', '正如我们所知道的，大整数的运算总是非常令人烦恼，但是它对于我们的OI比赛很重要，今天，你的任务就是写一个程序去计算A%B，为了使得问题更简单，保证B不大于100000，这个难吗？肯定不难，我花了10分钟就解决了，而且我的程序不超过25行。', '输入正整数A和B，A的位数不超过100000，B的大小不超过100000。即0&lt;A&lt;=10^100000,0&lt;B&lt;=100000。', '输出A%B的结果。结果占一行。', '2 3', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10179', '鸡兔同笼', '1000', '32768', '0', '0', '一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。', '每组测试数据占1行，每行一个正整数a (a &lt; 32768)', '输出包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开\r\n如果没有满足要求的答案，则输出两个0。', '3', '0 0', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10180', '简单计算器', '1000', '32768', '0', '0', '读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。', '输入占一行，不超过400个字符。运算符左右都有一个空格，没有非法表达式。', '对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。', '1 + 2', '3.00', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10181', '数组中的逆序对', '1000', '32768', '0', '0', '在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。', '第一行包含一个整数n，表示数组中的元素个数。其中1 &lt;= n &lt;= 10^3。\r\n第二行包含n个整数，每个数组均为int类型。', '对应每个测试案例，输出一个整数，表示数组中的逆序对的总数。', '4\r\n7 5 6 4', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10182', '水仙花数', '1000', '32768', '0', '0', '春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的：“水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=1^3+5^3+3^3。现在要求输出所有在m和n范围内的水仙花数。', '输入占一行，包括两个整数m和n（100&lt;=m&lt;=n&lt;=999）。', '输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;\\n如果给定的范围内不存在水仙花数，则输出no;\r\n每个测试实例的输出占一行。', '100 120', 'no', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10183', '位操作练习', '1000', '32768', '0', '0', '给出两个不大于65535的非负整数，判断其中一个的16位二进制表示形式，是否能由另一个的16位二进制表示形式经过循环左移若干位而得到。循环左移和普通左移的区别在于：最左边的那一位经过循环左移一位后就会被移到最右边去。比如：1011 0000 0000 0001 经过循环左移一位后，变成 0110 0000 0000 0011, 若是循环左移2位，则变成 1100 0000 0000 0110', '每行有两个不大于65535的非负整数', '对于每一行的两个整数，输出一行，内容为YES或NO', '2 4', 'YES', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10184', '最大连续子序列乘积', '1000', '32768', '0', '0', '给定一个浮点数序列（可能有正数、0和负数），求出一个最大的连续子序列乘积。', '输入的第一行仅包含正整数 n（n&lt;=1000000），表示浮点数序列的个数。\r\n第二行输入n个浮点数用空格分隔。\r\n输入数据保证所有数字乘积在双精度浮点数表示的范围内。', '输出序列中最大的连续子序列乘积，若乘积为浮点数请保留2位小数，如果乘积为整数，则输出整数，如果最大乘积为负数，输出-1。', '7\r\n-2.5 4 0 3 0.5 8 -1', '12', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10185', '2的次幂表示', '1000', '32768', '0', '0', '任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。\r\n\r\n　　将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0\r\n\r\n　　现在约定幂次用括号来表示，即a^b表示为a（b）\r\n\r\n　　此时，137可表示为：2（7）+2（3）+2（0）\r\n\r\n　　进一步：7=2^2+2+2^0 （2^1用2表示）\r\n\r\n　　3=2+2^0\r\n\r\n　　所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）\r\n\r\n　　又如：1315=2^10+2^8+2^5+2+1\r\n\r\n　　所以1315最后可表示为：\r\n\r\n　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）', '正整数（1&lt;=n&lt;=20000）。', '符合约定的n的0，2表示（在表示中不能有空格）', '137', '2(2(2)+2+2(0))+2(2+2(0))+2(0)', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10186', 'A变B', '1000', '32768', '0', '0', '给定两个正整数A,B（十进制）（0&lt;A,B&lt;2^31），把A，B转成二进制数表示后，问把A变成B至少需要改变多少位？例如：A=3，B=6，则A,B对应的二进制数分别是011,110，显然，把A的二进制变成B的二进制至少需要改变两位。', '输入两个正整数A,B（0&lt;A,B&lt;2^31）。', '输出把A变成B至少需要改变多少位，每个数占一行。', '1 14', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10187', '错误票据', '1000', '32768', '0', '0', '某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。你的任务是通过编程，找出断号的ID和重号的ID。假设断号不可能发生在最大和最小号。', '要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。\r\n接着读入N行数据。\r\n每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格。\r\n每个整数代表一个ID号。', '要求程序输出1行，含两个整数m n，用空格分隔。\r\n其中，m表示断号ID，n表示重号ID', '2\r\n5 6 8 11 9 \r\n10 12 9', '7 9', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10188', '单词数', '1000', '32768', '0', '0', 'lily的好朋友xiaoou333最近很空，他想了一件没有什么意义的事情，就是统计一篇文章里不同单词的总数。下面你的任务是帮助xiaoou333解决这个问题。', '每组一行，每组就是一篇小文章。每篇小文章都是由小写字母和空格组成，没有标点符号，字符串长度不超过4000。', '每组只输出一个整数，其单独成行，该整数代表一篇文章里不同单词的总数。', 'you are my friend', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10189', '分数二维数组之和', '1000', '32768', '0', '0', '我们定义如下矩阵:\r\n\r\n1/1 1/2 1/3\r\n\r\n1/2 1/1 1/2\r\n\r\n1/3 1/2 1/1\r\n\r\n矩阵对角线上的元素始终是1/1，对角线两边分数的分母逐个递增。\r\n\r\n请求出这个矩阵的总和。', '每行给定正整数N (N&lt;50000)，表示矩阵为 N*N。', '输出答案，保留2位小数。', '1', '1.00', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10190', '蚂蚁感冒', '1000', '32768', '0', '0', '长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。\r\n每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。\r\n当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。\r\n这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。\r\n请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。', '第一行输入一个整数n (1 &lt; n &lt; 50), 表示蚂蚁的总数。\r\n接着的一行是n个用空格分开的整数 Xi (-100 &lt; Xi &lt; 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。', '要求输出1个整数，表示最后感冒蚂蚁的数目。', '3\r\n5 -2 8', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10191', '排列数（2）', '1000', '32768', '0', '0', '0、1、2三个数字的全排列有六种，按照字母序排列如下：\r\n\r\n　　012、021、102、120、201、210\r\n\r\n　　输入一个数n\r\n\r\n　　求0~9十个数的全排列中的第n个（第1个为0123456789）。', '一行，包含一个整数n。数据规模和约定\r\n0 &lt; n &lt;= 10!', '一行，包含一组10个数字的排列。', '1', '0123456789', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10192', '亲和数', '1000', '32768', '0', '0', '古希腊数学家毕达哥拉斯在自然数研究中发现，220的所有真约数(即不是自身的约数)之和为： 1+2+4+5+10+11+20+22+44+55+110＝284。 而284的所有真约数为1、2、4、71、 142，加起来恰好为220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。 你的任务就编写一个程序，判断给定的两个数是否是亲和数', '输入数据每行包含两个整数A,B； 其中 0 &lt;= A,B &lt;= 600000 ;', '对于每个测试实例，如果A和B是亲和数的话输出YES，否则输出NO。', '220 284', 'YES', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10193', '讨厌62', '1000', '32768', '0', '0', '杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。', '输入的都是整数对n、m（0&lt;n≤m&lt;1000000）。', '对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。', '1 100', '80', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10194', '幸运数', '1000', '32768', '0', '0', '幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成。首先从1开始写出自然数1,2,3,4,5,6,....1 就是第一个幸运数。我们从2这个数开始。把所有序号能被2整除的项删除，变为：1 _ 3 _ 5 _ 7 _ 9 ....把它们缩紧，重新记序，为：1 3 5 7 9 .... 。这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, ...此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,...)最后剩下的序列类似：1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, ...', '输入两个正整数m n, 用空格分开 (m &lt; n &lt; 1000*1000)', '程序输出 位于m和n之间的幸运数的个数（不包含m和n）。', '1 20', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10195', '第K大公约数', '1000', '32768', '0', '0', '说给定正整数A和B，求第k大的公约数。', '输入三个数A，B，k。(1&lt;=A,B&lt;=10^12，0&lt;k&lt;=10^3)', '如果不存在，输出-1，否则输出第k大的公约数。', '2 4 2', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10196', '连号区间数', '1000', '32768', '0', '0', '小明这些天一直在思考这样一个奇怪而有趣的问题：在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。', '第一行是一个正整数N (1 &lt;= N &lt;= 1000), 表示全排列的规模。\\n\\n第二行是N个不同的数字Pi(1 &lt;= Pi &lt;= N)， 表示这N个数字的某一全排列。', '输出一个整数，表示不同连号区间的数目。', '4\r\n3 2 4 1', '7', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10197', 'N!(2)', '1000', '32768', '0', '0', '给定N,求N！的位数。', '输入一个数n。(0&lt;=a&lt;=10^7)', 'N！的位数。输出占一行。', '100', '158', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10198', '约数的个数', '1000', '32768', '0', '0', '输入1个整数,输出每个数的约数的个数', '接下来的1行包括N个整数，其中每个数的范围为(1&lt;=Num&lt;=1000000000)', '输出1行，对应上面的一个数的约数的个数。', '12', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10199', '整除问题', '1000', '32768', '0', '0', '给定n，a求最大的k，使n！可以被a^k整除但不能被a^(k+1)整除。', '两个整数n(2&lt;=n&lt;=1000)，a(2&lt;=a&lt;=1000)', '一个整数k.', '6 10', '1', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10200', '数组中的逆序对（2）', '1000', '32768', '0', '0', '在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。', '第一行包含一个整数n，表示数组中的元素个数。其中1 &lt;= n &lt;= 10^5。\r\n第二行包含n个整数，每个数组均为int类型。', '输出一个整数，表示数组中的逆序对的总数。', '4\r\n7 5 6 4', '5', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10201', 'Find Q', '1000', '32768', '0', '0', 'Byteasar迷恋上了\'q\'这个字母。在他眼前有一个小写字母组成的字符串SS，他想找出SS的所有仅包含字母\'q\'的连续子串。但是这个字符串实在是太长了，你能写个程序帮助他吗？', '输入包含一行一个小写字母组成字符串S，保证S的长度不超过100000。', '输出一行一个整数，即仅包含字母\'q\'的连续子串的个数。', 'quailtyqqq', '7', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10202', '区间调度问题2', '1000', '32768', '0', '0', '有n项工作, 每项工作的起止时间为[s[i], t[i]]. 每项工作的酬劳是a[i],对于每项工作, 你都可以选择是否参加, 但是如果参加一项工作后, 就必须在该项工作的起止时间内全程参与, 同一时刻你只能参加一种工作. 问最多可以得到多少酬劳. (可以在结束的时刻开始新的工作)', '第一行, 一个正整数n(1&lt;=n&lt;=2000), 表示有多少项工作.\r\n以下n行, 每行三个整数s[i], t[i],a[i](1&lt;=s[i]&lt;t[i]&lt;=10^9,1&lt;=a[i]&lt;10^9), 表示第1~n项工作的开始和结束时刻.', '输出最多能得到多少酬劳.', '5\r\n1 3 1\r\n2 5 2\r\n4 7 3\r\n6 9 4\r\n8 10 5', '9', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10203', '区间调度问题3', '1000', '32768', '0', '0', '有n项工作, 每项工作的起止时间为[s[i], t[i]].,对于每项工作, 你都可以选择是否参加, 但是如果参加一项工作后, 就必须在该项工作的起止时间内全程参与, 同一时刻你只能参加一种工作(第i个工作的时长是t[i]-s[i]). 问最多最长的工作时间是多少. (可以在结束的时刻开始新的工作)', '第一行, 一个正整数n(1&lt;=n&lt;=2000), 表示有多少项工作.\r\n以下n行, 每行三个整数s[i], t[i],a[i](1&lt;=s[i]&lt;t[i]&lt;=10^9,1&lt;=a[i]&lt;10^9), 表示第1~n项工作的开始和结束时刻.', '输出最多最长的工作时间是多少。', '5\r\n1 3\r\n3 5\r\n4 7\r\n6 9\r\n8 10', '4', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10204', '拼火柴', '1000', '32768', '0', '0', '调皮的陈老师把一堆长度相同的火柴剪成了各种各样长度的火柴。现在他又想把这些长短不一的火柴拼回原来的状态，但是他已经忘了最初火柴的长度以及有多少根火柴了，请帮助他设计一个程序计算出原来最少有多少根长度相同的火柴。', '第一行是一个整数n，代表有n根火柴。\r\n第二行是n根火柴的长度(均为整数)，每个数以空格隔开。最多有64根火柴，每根火柴长度小于等于50。', '输出能还原多的所有方案中，长度最小的那种方案。\r\n只输出一个整数，代表最小长度。', '9\r\n5 2 1 5 2 1 5 2 1', '6', '吴迎', 'TCOJ', '1', '256', '10', '0');
INSERT INTO `problem` VALUES ('10205', 'LELE的RPG难题', '1000', '32768', '0', '0', '人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即&quot;可乐&quot;）,经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.以上就是著名的RPG难题.如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?', '输入占一行,由一个整数N组成，(0&lt;n&lt;=50)。', '请输出全部的满足要求的涂法，输出占一行。', '1', '2', '吴迎', 'TCOJ', '1', '256', '10', '0');

-- ----------------------------
-- Table structure for problem_label
-- ----------------------------
DROP TABLE IF EXISTS `problem_label`;
CREATE TABLE `problem_label` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `problem_id` int(11) NOT NULL,
  `label_id` int(11) NOT NULL,
  `status` int(5) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=236 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of problem_label
-- ----------------------------
INSERT INTO `problem_label` VALUES ('1', '10001', '1', '0');
INSERT INTO `problem_label` VALUES ('2', '10002', '1', '0');
INSERT INTO `problem_label` VALUES ('3', '10003', '1', '0');
INSERT INTO `problem_label` VALUES ('4', '10004', '1', '0');
INSERT INTO `problem_label` VALUES ('5', '10005', '1', '0');
INSERT INTO `problem_label` VALUES ('6', '10006', '1', '0');
INSERT INTO `problem_label` VALUES ('7', '10007', '1', '0');
INSERT INTO `problem_label` VALUES ('8', '10008', '1', '0');
INSERT INTO `problem_label` VALUES ('9', '10009', '1', '0');
INSERT INTO `problem_label` VALUES ('10', '10010', '2', '0');
INSERT INTO `problem_label` VALUES ('11', '10011', '1', '0');
INSERT INTO `problem_label` VALUES ('12', '10012', '1', '0');
INSERT INTO `problem_label` VALUES ('13', '10013', '3', '0');
INSERT INTO `problem_label` VALUES ('14', '10014', '1', '0');
INSERT INTO `problem_label` VALUES ('15', '10015', '1', '0');
INSERT INTO `problem_label` VALUES ('16', '10016', '2', '0');
INSERT INTO `problem_label` VALUES ('17', '10017', '1', '0');
INSERT INTO `problem_label` VALUES ('18', '10018', '2', '0');
INSERT INTO `problem_label` VALUES ('19', '10019', '2', '0');
INSERT INTO `problem_label` VALUES ('20', '10020', '2', '0');
INSERT INTO `problem_label` VALUES ('21', '10021', '2', '0');
INSERT INTO `problem_label` VALUES ('22', '10022', '2', '0');
INSERT INTO `problem_label` VALUES ('23', '10022', '4', '0');
INSERT INTO `problem_label` VALUES ('24', '10023', '2', '0');
INSERT INTO `problem_label` VALUES ('25', '10023', '4', '0');
INSERT INTO `problem_label` VALUES ('26', '10024', '2', '0');
INSERT INTO `problem_label` VALUES ('27', '10024', '4', '0');
INSERT INTO `problem_label` VALUES ('28', '10025', '2', '0');
INSERT INTO `problem_label` VALUES ('29', '10026', '2', '0');
INSERT INTO `problem_label` VALUES ('30', '10026', '4', '0');
INSERT INTO `problem_label` VALUES ('31', '10027', '2', '0');
INSERT INTO `problem_label` VALUES ('32', '10027', '4', '0');
INSERT INTO `problem_label` VALUES ('33', '10028', '2', '0');
INSERT INTO `problem_label` VALUES ('34', '10028', '4', '1');
INSERT INTO `problem_label` VALUES ('35', '10028', '3', '0');
INSERT INTO `problem_label` VALUES ('36', '10029', '1', '0');
INSERT INTO `problem_label` VALUES ('37', '10029', '3', '0');
INSERT INTO `problem_label` VALUES ('38', '10030', '2', '0');
INSERT INTO `problem_label` VALUES ('39', '10030', '4', '0');
INSERT INTO `problem_label` VALUES ('40', '10031', '2', '0');
INSERT INTO `problem_label` VALUES ('41', '10032', '2', '0');
INSERT INTO `problem_label` VALUES ('42', '10033', '2', '0');
INSERT INTO `problem_label` VALUES ('43', '10033', '4', '0');
INSERT INTO `problem_label` VALUES ('44', '10034', '2', '0');
INSERT INTO `problem_label` VALUES ('45', '10034', '4', '0');
INSERT INTO `problem_label` VALUES ('46', '10036', '2', '0');
INSERT INTO `problem_label` VALUES ('47', '10036', '4', '0');
INSERT INTO `problem_label` VALUES ('48', '10035', '2', '0');
INSERT INTO `problem_label` VALUES ('49', '10035', '4', '0');
INSERT INTO `problem_label` VALUES ('50', '10037', '2', '0');
INSERT INTO `problem_label` VALUES ('51', '10037', '4', '0');
INSERT INTO `problem_label` VALUES ('52', '10038', '2', '0');
INSERT INTO `problem_label` VALUES ('53', '10039', '2', '0');
INSERT INTO `problem_label` VALUES ('54', '10040', '2', '0');
INSERT INTO `problem_label` VALUES ('55', '10041', '2', '0');
INSERT INTO `problem_label` VALUES ('56', '10042', '2', '0');
INSERT INTO `problem_label` VALUES ('57', '10043', '2', '0');
INSERT INTO `problem_label` VALUES ('58', '10044', '2', '0');
INSERT INTO `problem_label` VALUES ('59', '10045', '2', '0');
INSERT INTO `problem_label` VALUES ('60', '10046', '2', '0');
INSERT INTO `problem_label` VALUES ('61', '10047', '2', '0');
INSERT INTO `problem_label` VALUES ('62', '10048', '2', '0');
INSERT INTO `problem_label` VALUES ('63', '10049', '2', '0');
INSERT INTO `problem_label` VALUES ('64', '10050', '1', '0');
INSERT INTO `problem_label` VALUES ('65', '10051', '1', '0');
INSERT INTO `problem_label` VALUES ('66', '10052', '1', '0');
INSERT INTO `problem_label` VALUES ('67', '10053', '1', '0');
INSERT INTO `problem_label` VALUES ('68', '10054', '1', '0');
INSERT INTO `problem_label` VALUES ('69', '10055', '1', '0');
INSERT INTO `problem_label` VALUES ('70', '10056', '1', '0');
INSERT INTO `problem_label` VALUES ('71', '10057', '1', '0');
INSERT INTO `problem_label` VALUES ('72', '10058', '1', '0');
INSERT INTO `problem_label` VALUES ('73', '10059', '1', '0');
INSERT INTO `problem_label` VALUES ('74', '10060', '1', '0');
INSERT INTO `problem_label` VALUES ('75', '10061', '1', '0');
INSERT INTO `problem_label` VALUES ('76', '10062', '1', '0');
INSERT INTO `problem_label` VALUES ('77', '10063', '1', '0');
INSERT INTO `problem_label` VALUES ('78', '10064', '1', '0');
INSERT INTO `problem_label` VALUES ('79', '10065', '1', '0');
INSERT INTO `problem_label` VALUES ('80', '10066', '2', '0');
INSERT INTO `problem_label` VALUES ('81', '10067', '5', '0');
INSERT INTO `problem_label` VALUES ('82', '10068', '5', '0');
INSERT INTO `problem_label` VALUES ('83', '10069', '5', '0');
INSERT INTO `problem_label` VALUES ('84', '10069', '6', '0');
INSERT INTO `problem_label` VALUES ('85', '10070', '5', '0');
INSERT INTO `problem_label` VALUES ('86', '10071', '5', '0');
INSERT INTO `problem_label` VALUES ('87', '10072', '5', '0');
INSERT INTO `problem_label` VALUES ('88', '10073', '5', '0');
INSERT INTO `problem_label` VALUES ('89', '10074', '1', '0');
INSERT INTO `problem_label` VALUES ('90', '10075', '7', '0');
INSERT INTO `problem_label` VALUES ('91', '10076', '4', '0');
INSERT INTO `problem_label` VALUES ('92', '10076', '8', '0');
INSERT INTO `problem_label` VALUES ('93', '10077', '8', '0');
INSERT INTO `problem_label` VALUES ('94', '10078', '8', '0');
INSERT INTO `problem_label` VALUES ('95', '10079', '7', '0');
INSERT INTO `problem_label` VALUES ('96', '10080', '7', '0');
INSERT INTO `problem_label` VALUES ('97', '10081', '7', '0');
INSERT INTO `problem_label` VALUES ('98', '10081', '9', '0');
INSERT INTO `problem_label` VALUES ('99', '10082', '7', '0');
INSERT INTO `problem_label` VALUES ('100', '10083', '5', '0');
INSERT INTO `problem_label` VALUES ('101', '10083', '10', '0');
INSERT INTO `problem_label` VALUES ('102', '10084', '7', '0');
INSERT INTO `problem_label` VALUES ('103', '10084', '11', '0');
INSERT INTO `problem_label` VALUES ('104', '10085', '7', '0');
INSERT INTO `problem_label` VALUES ('105', '10086', '10', '0');
INSERT INTO `problem_label` VALUES ('106', '10087', '10', '0');
INSERT INTO `problem_label` VALUES ('107', '10088', '9', '0');
INSERT INTO `problem_label` VALUES ('108', '10089', '9', '0');
INSERT INTO `problem_label` VALUES ('109', '10090', '9', '0');
INSERT INTO `problem_label` VALUES ('110', '10091', '9', '0');
INSERT INTO `problem_label` VALUES ('111', '10092', '9', '0');
INSERT INTO `problem_label` VALUES ('112', '10092', '12', '0');
INSERT INTO `problem_label` VALUES ('113', '10093', '13', '0');
INSERT INTO `problem_label` VALUES ('114', '10094', '13', '0');
INSERT INTO `problem_label` VALUES ('115', '10094', '14', '0');
INSERT INTO `problem_label` VALUES ('116', '10095', '13', '0');
INSERT INTO `problem_label` VALUES ('117', '10096', '13', '0');
INSERT INTO `problem_label` VALUES ('118', '10097', '15', '0');
INSERT INTO `problem_label` VALUES ('119', '10098', '5', '0');
INSERT INTO `problem_label` VALUES ('120', '10099', '15', '0');
INSERT INTO `problem_label` VALUES ('121', '10101', '3', '0');
INSERT INTO `problem_label` VALUES ('122', '10102', '3', '0');
INSERT INTO `problem_label` VALUES ('123', '10103', '3', '0');
INSERT INTO `problem_label` VALUES ('124', '10104', '3', '0');
INSERT INTO `problem_label` VALUES ('125', '10105', '3', '0');
INSERT INTO `problem_label` VALUES ('126', '10105', '7', '0');
INSERT INTO `problem_label` VALUES ('127', '10106', '3', '0');
INSERT INTO `problem_label` VALUES ('128', '10107', '3', '0');
INSERT INTO `problem_label` VALUES ('129', '10108', '13', '0');
INSERT INTO `problem_label` VALUES ('130', '10109', '13', '0');
INSERT INTO `problem_label` VALUES ('131', '10110', '13', '0');
INSERT INTO `problem_label` VALUES ('132', '10111', '13', '0');
INSERT INTO `problem_label` VALUES ('133', '10111', '6', '0');
INSERT INTO `problem_label` VALUES ('134', '10112', '16', '0');
INSERT INTO `problem_label` VALUES ('135', '10113', '16', '0');
INSERT INTO `problem_label` VALUES ('136', '10114', '3', '0');
INSERT INTO `problem_label` VALUES ('137', '10115', '16', '0');
INSERT INTO `problem_label` VALUES ('138', '10116', '16', '0');
INSERT INTO `problem_label` VALUES ('139', '10117', '16', '0');
INSERT INTO `problem_label` VALUES ('140', '10118', '10', '0');
INSERT INTO `problem_label` VALUES ('141', '10118', '6', '0');
INSERT INTO `problem_label` VALUES ('142', '10119', '10', '0');
INSERT INTO `problem_label` VALUES ('143', '10119', '6', '0');
INSERT INTO `problem_label` VALUES ('144', '10120', '17', '0');
INSERT INTO `problem_label` VALUES ('145', '10120', '6', '0');
INSERT INTO `problem_label` VALUES ('146', '10121', '16', '0');
INSERT INTO `problem_label` VALUES ('147', '10121', '6', '0');
INSERT INTO `problem_label` VALUES ('148', '10122', '4', '0');
INSERT INTO `problem_label` VALUES ('149', '10122', '6', '0');
INSERT INTO `problem_label` VALUES ('150', '10123', '3', '0');
INSERT INTO `problem_label` VALUES ('151', '10123', '6', '0');
INSERT INTO `problem_label` VALUES ('152', '10124', '6', '0');
INSERT INTO `problem_label` VALUES ('153', '10125', '6', '0');
INSERT INTO `problem_label` VALUES ('154', '10126', '6', '0');
INSERT INTO `problem_label` VALUES ('155', '10127', '6', '0');
INSERT INTO `problem_label` VALUES ('156', '10128', '6', '0');
INSERT INTO `problem_label` VALUES ('157', '10129', '6', '0');
INSERT INTO `problem_label` VALUES ('158', '10130', '6', '0');
INSERT INTO `problem_label` VALUES ('159', '10131', '6', '0');
INSERT INTO `problem_label` VALUES ('160', '10132', '3', '0');
INSERT INTO `problem_label` VALUES ('161', '10133', '14', '0');
INSERT INTO `problem_label` VALUES ('162', '10134', '14', '0');
INSERT INTO `problem_label` VALUES ('163', '10135', '14', '0');
INSERT INTO `problem_label` VALUES ('164', '10136', '14', '0');
INSERT INTO `problem_label` VALUES ('165', '10137', '7', '0');
INSERT INTO `problem_label` VALUES ('166', '10138', '1', '0');
INSERT INTO `problem_label` VALUES ('167', '10139', '1', '0');
INSERT INTO `problem_label` VALUES ('168', '10140', '1', '0');
INSERT INTO `problem_label` VALUES ('169', '10141', '2', '0');
INSERT INTO `problem_label` VALUES ('170', '10142', '2', '0');
INSERT INTO `problem_label` VALUES ('171', '10143', '2', '0');
INSERT INTO `problem_label` VALUES ('172', '10144', '8', '0');
INSERT INTO `problem_label` VALUES ('173', '10145', '8', '0');
INSERT INTO `problem_label` VALUES ('174', '10146', '8', '0');
INSERT INTO `problem_label` VALUES ('175', '10147', '8', '0');
INSERT INTO `problem_label` VALUES ('176', '10148', '8', '0');
INSERT INTO `problem_label` VALUES ('177', '10149', '8', '0');
INSERT INTO `problem_label` VALUES ('178', '10150', '8', '0');
INSERT INTO `problem_label` VALUES ('179', '10151', '8', '0');
INSERT INTO `problem_label` VALUES ('180', '10152', '8', '0');
INSERT INTO `problem_label` VALUES ('181', '10153', '15', '0');
INSERT INTO `problem_label` VALUES ('182', '10154', '11', '0');
INSERT INTO `problem_label` VALUES ('183', '10155', '3', '0');
INSERT INTO `problem_label` VALUES ('184', '10156', '10', '0');
INSERT INTO `problem_label` VALUES ('185', '10156', '14', '0');
INSERT INTO `problem_label` VALUES ('186', '10157', '9', '0');
INSERT INTO `problem_label` VALUES ('187', '10157', '11', '0');
INSERT INTO `problem_label` VALUES ('188', '10158', '3', '0');
INSERT INTO `problem_label` VALUES ('189', '10159', '15', '0');
INSERT INTO `problem_label` VALUES ('190', '10160', '18', '0');
INSERT INTO `problem_label` VALUES ('191', '10161', '18', '0');
INSERT INTO `problem_label` VALUES ('192', '10163', '8', '0');
INSERT INTO `problem_label` VALUES ('193', '10164', '3', '0');
INSERT INTO `problem_label` VALUES ('194', '10165', '16', '0');
INSERT INTO `problem_label` VALUES ('195', '10166', '5', '0');
INSERT INTO `problem_label` VALUES ('196', '10167', '18', '0');
INSERT INTO `problem_label` VALUES ('197', '10168', '11', '0');
INSERT INTO `problem_label` VALUES ('198', '10169', '12', '0');
INSERT INTO `problem_label` VALUES ('199', '10170', '5', '0');
INSERT INTO `problem_label` VALUES ('200', '10170', '7', '0');
INSERT INTO `problem_label` VALUES ('201', '10171', '14', '0');
INSERT INTO `problem_label` VALUES ('202', '10172', '10', '0');
INSERT INTO `problem_label` VALUES ('203', '10173', '11', '0');
INSERT INTO `problem_label` VALUES ('204', '10174', '10', '0');
INSERT INTO `problem_label` VALUES ('205', '10175', '19', '0');
INSERT INTO `problem_label` VALUES ('206', '10176', '5', '0');
INSERT INTO `problem_label` VALUES ('207', '10177', '13', '0');
INSERT INTO `problem_label` VALUES ('208', '10178', '13', '0');
INSERT INTO `problem_label` VALUES ('209', '10179', '3', '0');
INSERT INTO `problem_label` VALUES ('210', '10180', '20', '0');
INSERT INTO `problem_label` VALUES ('211', '10181', '7', '0');
INSERT INTO `problem_label` VALUES ('212', '10182', '7', '0');
INSERT INTO `problem_label` VALUES ('213', '10183', '20', '0');
INSERT INTO `problem_label` VALUES ('214', '10184', '18', '0');
INSERT INTO `problem_label` VALUES ('215', '10185', '9', '0');
INSERT INTO `problem_label` VALUES ('216', '10186', '12', '0');
INSERT INTO `problem_label` VALUES ('217', '10187', '7', '0');
INSERT INTO `problem_label` VALUES ('218', '10188', '7', '0');
INSERT INTO `problem_label` VALUES ('219', '10189', '3', '0');
INSERT INTO `problem_label` VALUES ('220', '10190', '20', '0');
INSERT INTO `problem_label` VALUES ('221', '10191', '16', '0');
INSERT INTO `problem_label` VALUES ('222', '10192', '7', '0');
INSERT INTO `problem_label` VALUES ('223', '10193', '7', '0');
INSERT INTO `problem_label` VALUES ('224', '10194', '3', '0');
INSERT INTO `problem_label` VALUES ('225', '10195', '15', '0');
INSERT INTO `problem_label` VALUES ('226', '10196', '3', '0');
INSERT INTO `problem_label` VALUES ('227', '10197', '3', '0');
INSERT INTO `problem_label` VALUES ('228', '10198', '3', '0');
INSERT INTO `problem_label` VALUES ('229', '10199', '3', '0');
INSERT INTO `problem_label` VALUES ('230', '10200', '14', '0');
INSERT INTO `problem_label` VALUES ('231', '10201', '7', '0');
INSERT INTO `problem_label` VALUES ('232', '10202', '18', '0');
INSERT INTO `problem_label` VALUES ('233', '10203', '18', '0');
INSERT INTO `problem_label` VALUES ('234', '10204', '16', '0');
INSERT INTO `problem_label` VALUES ('235', '10205', '11', '0');

-- ----------------------------
-- Table structure for register
-- ----------------------------
DROP TABLE IF EXISTS `register`;
CREATE TABLE `register` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(40) NOT NULL,
  `password` varchar(40) NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '0',
  `school` varchar(30) NOT NULL DEFAULT '0',
  `motto` varchar(100) NOT NULL,
  `mail` varchar(50) NOT NULL,
  `realname` varchar(20) NOT NULL,
  `major` varchar(30) NOT NULL,
  `nickname` varchar(50) NOT NULL,
  `register_time` int(11) NOT NULL,
  `hash` varchar(255) NOT NULL,
  `ip` varchar(255) NOT NULL,
  `area` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of register
-- ----------------------------
INSERT INTO `register` VALUES ('1', 'wuying', '2603cfd8dc21529c2f660ac8d0a4cbdb', '1', '江西师范大学', '楼下的都是弱鸡', '529194793@qq.com', '吴迎', '物联网', '吴迎', '1493261122', 'OB0ROGgrwJAa3ZQ0Zanrru1rZF7tJUwvgXzZG17V', '0.0.0.0', 'IANA保留地址CZ88.NET');

-- ----------------------------
-- Table structure for train_comment
-- ----------------------------
DROP TABLE IF EXISTS `train_comment`;
CREATE TABLE `train_comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `level_msg_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `comment` text NOT NULL,
  `submit_time` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of train_comment
-- ----------------------------

-- ----------------------------
-- Table structure for train_judge_detail
-- ----------------------------
DROP TABLE IF EXISTS `train_judge_detail`;
CREATE TABLE `train_judge_detail` (
  `id` int(9) unsigned NOT NULL AUTO_INCREMENT,
  `user_problem_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  `judge_status` int(11) NOT NULL DEFAULT '8',
  `exe_time` int(11) NOT NULL DEFAULT '0',
  `exe_memory` int(11) NOT NULL DEFAULT '0',
  `score` int(11) NOT NULL DEFAULT '0',
  `input_file_path` varchar(255) NOT NULL,
  `output_file_path` varchar(255) NOT NULL,
  `group_score` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of train_judge_detail
-- ----------------------------

-- ----------------------------
-- Table structure for train_problem
-- ----------------------------
DROP TABLE IF EXISTS `train_problem`;
CREATE TABLE `train_problem` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `level_msg_id` int(11) NOT NULL DEFAULT '0',
  `title` text NOT NULL,
  `time_limit` int(7) NOT NULL DEFAULT '1000',
  `memory_limit` int(7) NOT NULL DEFAULT '32768',
  `submissions` int(7) NOT NULL DEFAULT '0',
  `accepted` int(7) NOT NULL DEFAULT '0',
  `description` text NOT NULL,
  `input` text NOT NULL,
  `output` text NOT NULL,
  `sample_input` text NOT NULL,
  `sample_output` text NOT NULL,
  `author` text NOT NULL,
  `source` text NOT NULL,
  `status` int(9) NOT NULL DEFAULT '1',
  `output_limit` int(9) DEFAULT '0',
  `case_number` int(11) NOT NULL DEFAULT '10',
  `difficulty` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of train_problem
-- ----------------------------

-- ----------------------------
-- Table structure for train_rank
-- ----------------------------
DROP TABLE IF EXISTS `train_rank`;
CREATE TABLE `train_rank` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `level_msg_id` int(11) NOT NULL,
  `solve_problem` int(11) NOT NULL,
  `submissions` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of train_rank
-- ----------------------------

-- ----------------------------
-- Table structure for train_user_problem
-- ----------------------------
DROP TABLE IF EXISTS `train_user_problem`;
CREATE TABLE `train_user_problem` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `user_id` int(6) NOT NULL,
  `problem_id` int(6) NOT NULL,
  `submit_time` int(11) NOT NULL,
  `judge_status` int(1) NOT NULL,
  `exe_time` int(6) NOT NULL DEFAULT '0',
  `exe_memory` int(6) NOT NULL,
  `code_len` int(6) NOT NULL,
  `language` varchar(30) NOT NULL,
  `nickname` varchar(30) NOT NULL,
  `filepath` varchar(30) NOT NULL,
  `judge_results` int(1) NOT NULL DEFAULT '0',
  `level_msg_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of train_user_problem
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(40) NOT NULL,
  `password` varchar(255) NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '2',
  `root` int(1) NOT NULL DEFAULT '0',
  `accepted` int(10) NOT NULL DEFAULT '0',
  `submissions` int(10) NOT NULL DEFAULT '0',
  `solve_problem` int(10) NOT NULL DEFAULT '0',
  `school` varchar(255) NOT NULL DEFAULT '0',
  `Submitted_problem` int(10) NOT NULL DEFAULT '0',
  `motto` varchar(100) NOT NULL,
  `mail` varchar(50) NOT NULL,
  `realname` varchar(255) NOT NULL,
  `major` varchar(255) NOT NULL,
  `nickname` varchar(255) NOT NULL,
  `register_time` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'wuying', '19fb510192192080ff47abaf66dbdbdf', '1', '2', '0', '0', '0', '江西师范大学', '0', '楼下的都是弱鸡', '529194793@qq.com', '吴迎', '物联网', '吴迎', '1493261122');

-- ----------------------------
-- Table structure for user_problem
-- ----------------------------
DROP TABLE IF EXISTS `user_problem`;
CREATE TABLE `user_problem` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `user_id` int(6) NOT NULL,
  `problem_id` int(6) NOT NULL,
  `submit_time` int(11) NOT NULL,
  `judge_status` int(1) NOT NULL,
  `exe_time` int(6) NOT NULL DEFAULT '0',
  `exe_memory` int(6) NOT NULL,
  `code_len` int(6) NOT NULL,
  `language` varchar(30) NOT NULL,
  `nickname` varchar(30) NOT NULL,
  `filepath` text NOT NULL,
  `judge_results` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user_problem
-- ----------------------------
